<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
  <Token>
    <TokenIdentifier>
      <Name>porting</Name>
      <APILanguage>c</APILanguage>
    </TokenIdentifier>
    <Path>porting.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>md__home_algebrato_Progetti_CMB4G_libcal_src_pycal_pybind11_CONTRIBUTING</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>md__home_algebrato__progetti__c_m_b4_g_libcal_src_pycal_pybind11__c_o_n_t_r_i_b_u_t_i_n_g.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>md__home_algebrato_Progetti_CMB4G_libcal_src_pycal_pybind11_ISSUE_TEMPLATE</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>md__home_algebrato__progetti__c_m_b4_g_libcal_src_pycal_pybind11__i_s_s_u_e__t_e_m_p_l_a_t_e.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>md__home_algebrato_Progetti_CMB4G_libcal_src_pycal_pybind11_README</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>md__home_algebrato__progetti__c_m_b4_g_libcal_src_pycal_pybind11__r_e_a_d_m_e.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>md__home_algebrato_Progetti_CMB4G_libcal_src_pycal_tests_README</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>md__home_algebrato__progetti__c_m_b4_g_libcal_src_pycal_tests__r_e_a_d_m_e.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>church_model</Name>
      <APILanguage>markdown</APILanguage>
    </TokenIdentifier>
    <Path>church_model.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>python_builtins</Name>
      <APILanguage>c</APILanguage>
    </TokenIdentifier>
    <Path>group__python__builtins.html</Path>
    <Abstract>Unless stated otherwise, the following C++ functions behave the same as their Python counterparts.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>globals</Name>
      <APILanguage>c</APILanguage>
      <Type>func</Type>
    </TokenIdentifier>
    <Path>group__python__builtins.html</Path>
    <Anchor>ga0be04c9e8c8a6833cabae628e2243b6c</Anchor>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isinstance</Name>
      <APILanguage>c</APILanguage>
      <Type>func</Type>
    </TokenIdentifier>
    <Path>group__python__builtins.html</Path>
    <Anchor>gade020f155a1f133cc9e245bac2981280</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>isinstance</Name>
      <APILanguage>c</APILanguage>
      <Type>func</Type>
    </TokenIdentifier>
    <Path>group__python__builtins.html</Path>
    <Anchor>ga563dccaeb6eca82ece3f56c5edfe838b</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>annotations</Name>
      <APILanguage>c</APILanguage>
    </TokenIdentifier>
    <Path>group__annotations.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pytypes</Name>
      <APILanguage>c</APILanguage>
    </TokenIdentifier>
    <Path>group__pytypes.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>A</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>A</Scope>
    </TokenIdentifier>
    <Path>struct_a.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>A_Repeat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>A_Repeat</Scope>
    </TokenIdentifier>
    <Path>class_a___repeat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>A_Tpl</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>A_Tpl</Scope>
    </TokenIdentifier>
    <Path>class_a___tpl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>accessor</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>accessor</Scope>
    </TokenIdentifier>
    <Path>classaccessor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>alias_constructor</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>alias_constructor</Scope>
    </TokenIdentifier>
    <Path>structalias__constructor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>always_construct_holder</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>always_construct_holder</Scope>
    </TokenIdentifier>
    <Path>structalways__construct__holder.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Animal</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Animal</Scope>
    </TokenIdentifier>
    <Path>struct_animal.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>any_container</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>any_container</Scope>
    </TokenIdentifier>
    <Path>classany__container.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>arg</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>arg</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>ae6211325dd7551f254b0428f9e1e4e4c</Anchor>
    <Abstract>Constructs an argument with the name of the argument; if null or omitted, this is a positional argume...</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator=</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>af21c066dfb7fe62ff952a8ea4713b7ed</Anchor>
    <Abstract>Assign a value to this argument.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>noconvert</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>affdcf2c99a2f27cb539efd6853335d4b</Anchor>
    <Abstract>Indicate that the type should not be converted in the type caster.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>a99082d77a1a365593a16939f03194e5e</Anchor>
    <Abstract>Indicates that the argument should/shouldn&apos;t allow None (e.g. for nullable pointer args)</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>name</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>a19d6eebdcc5e2c4679c5f77760adb5dc</Anchor>
    <Abstract>If non-null, this is a named kwargs argument.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>flag_noconvert</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>af69a71cd0c34cbce3ef8705e7b7da817</Anchor>
    <Abstract>If set, do not allow conversion (requires a supporting type caster!)</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>flag_none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>a57121005d089a7b05536d320ebc9d32f</Anchor>
    <Abstract>If set (the default), allow None to be passed to this argument.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>arg_v</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>arg_v</Scope>
    </TokenIdentifier>
    <Path>structarg__v.html</Path>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>arg_v</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg_v</Scope>
    </TokenIdentifier>
    <Path>structarg__v.html</Path>
    <Anchor>a7d90c329733699b99eccbb55797d65fb</Anchor>
    <Abstract>Direct construction with name, default, and description.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>arg_v</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg_v</Scope>
    </TokenIdentifier>
    <Path>structarg__v.html</Path>
    <Anchor>a0a3a669c2b644bf122c3363d88c5dea6</Anchor>
    <Abstract>Called internally when invoking py::arg(&quot;a&quot;) = value</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>noconvert</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg_v</Scope>
    </TokenIdentifier>
    <Path>structarg__v.html</Path>
    <Anchor>a018e928b16cc3e83065740a92a490d07</Anchor>
    <Abstract>Same as arg::noconvert(), but returns *this as arg_v&amp;, not arg&amp;.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg_v</Scope>
    </TokenIdentifier>
    <Path>structarg__v.html</Path>
    <Anchor>a3d487f117dc8f3af6555519ab160716a</Anchor>
    <Abstract>Same as arg::nonone(), but returns *this as arg_v&amp;, not arg&amp;.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>arg</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>ae6211325dd7551f254b0428f9e1e4e4c</Anchor>
    <Abstract>Constructs an argument with the name of the argument; if null or omitted, this is a positional argume...</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator=</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>af21c066dfb7fe62ff952a8ea4713b7ed</Anchor>
    <Abstract>Assign a value to this argument.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>noconvert</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>affdcf2c99a2f27cb539efd6853335d4b</Anchor>
    <Abstract>Indicate that the type should not be converted in the type caster.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>a99082d77a1a365593a16939f03194e5e</Anchor>
    <Abstract>Indicates that the argument should/shouldn&apos;t allow None (e.g. for nullable pointer args)</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>value</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg_v</Scope>
    </TokenIdentifier>
    <Path>structarg__v.html</Path>
    <Anchor>a3fe738ed6397b48b88244151dab53ee1</Anchor>
    <Abstract>The default value.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>descr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg_v</Scope>
    </TokenIdentifier>
    <Path>structarg__v.html</Path>
    <Anchor>a0a50cfb966acfce71fd61974a31f2a75</Anchor>
    <Abstract>The (optional) description of the default value.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg_v</Scope>
    </TokenIdentifier>
    <Path>structarg__v.html</Path>
    <Anchor>a772bc79a04bfa30ab09034927be549ad</Anchor>
    <Abstract>The C++ type name of the default value (only available when compiled in debug mode)</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>name</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>a19d6eebdcc5e2c4679c5f77760adb5dc</Anchor>
    <Abstract>If non-null, this is a named kwargs argument.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>flag_noconvert</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>af69a71cd0c34cbce3ef8705e7b7da817</Anchor>
    <Abstract>If set, do not allow conversion (requires a supporting type caster!)</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>flag_none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>arg</Scope>
    </TokenIdentifier>
    <Path>structarg.html</Path>
    <Anchor>a57121005d089a7b05536d320ebc9d32f</Anchor>
    <Abstract>If set (the default), allow None to be passed to this argument.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ArgAlwaysConverts</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ArgAlwaysConverts</Scope>
    </TokenIdentifier>
    <Path>class_arg_always_converts.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ArgInspector1</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ArgInspector1</Scope>
    </TokenIdentifier>
    <Path>class_arg_inspector1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ArgInspector2</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ArgInspector2</Scope>
    </TokenIdentifier>
    <Path>class_arg_inspector2.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>args</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>args</Scope>
    </TokenIdentifier>
    <Path>classargs.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>args_proxy</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>args_proxy</Scope>
    </TokenIdentifier>
    <Path>classargs__proxy.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>argument_loader</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>argument_loader</Scope>
    </TokenIdentifier>
    <Path>classargument__loader.html</Path>
    <Abstract>Helper class which loads arguments for C++ functions called from Python.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>argument_record</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>argument_record</Scope>
    </TokenIdentifier>
    <Path>structargument__record.html</Path>
    <Abstract>Internal data structure which holds metadata about a keyword argument.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>name</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>argument_record</Scope>
    </TokenIdentifier>
    <Path>structargument__record.html</Path>
    <Anchor>ac9bb5bf320b8eb1de1ef5f9dcc808269</Anchor>
    <Abstract>Argument name.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>descr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>argument_record</Scope>
    </TokenIdentifier>
    <Path>structargument__record.html</Path>
    <Anchor>a5bee7fa9c31dc8e5e1b9406cb483e610</Anchor>
    <Abstract>Human-readable version of the argument value.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>value</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>argument_record</Scope>
    </TokenIdentifier>
    <Path>structargument__record.html</Path>
    <Anchor>a3d6ba6a0cb59834720cb7d7df5bdb2c2</Anchor>
    <Abstract>Associated Python object.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>convert</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>argument_record</Scope>
    </TokenIdentifier>
    <Path>structargument__record.html</Path>
    <Anchor>ab885e9c26fb95309b6f3f03410f36d30</Anchor>
    <Abstract>True if the argument is allowed to convert when loading.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>argument_record</Scope>
    </TokenIdentifier>
    <Path>structargument__record.html</Path>
    <Anchor>a62c9d868218688cd4abde4634646848c</Anchor>
    <Abstract>True if None is allowed when loading.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>arithmetic</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>arithmetic</Scope>
    </TokenIdentifier>
    <Path>structarithmetic.html</Path>
    <Abstract>Annotation to mark enums as an arithmetic type.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dtype</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a49535f32396582e415a61f3aac9c78b3</Anchor>
    <Abstract>Array descriptor (dtype)</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>size</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a34ae467d17d30b99913e27c755403fef</Anchor>
    <Abstract>Total number of elements.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>itemsize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>acd6aa4dba1e1db26fcfd21a323b4d4fa</Anchor>
    <Abstract>Byte size of a single element.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nbytes</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a0a2a16579bf2918347a8762c03f10137</Anchor>
    <Abstract>Total number of bytes.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ndim</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a184360492eac7224753f132d1a0a973e</Anchor>
    <Abstract>Number of dimensions.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>base</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a33a2f2933da6ca35a8ac82709df90038</Anchor>
    <Abstract>Base object.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>shape</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a084781a3d2cb3ea60ab7bcf16c30ee31</Anchor>
    <Abstract>Dimensions of the array.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>shape</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>aceb118afe3a4eed2b3c9ec958505e414</Anchor>
    <Abstract>Dimension along a given axis.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>strides</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a3dd7d4e8f6d93e5714a642a3250df6e3</Anchor>
    <Abstract>Strides of the array.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>strides</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>afb8e09341f7884d6b34d454b2992c7ce</Anchor>
    <Abstract>Stride along a given axis.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>flags</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a38eb48c793621c12119ab7b64714955b</Anchor>
    <Abstract>Return the NumPy array flags.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>writeable</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a9c19f81ca43feebd34b2c9dd5b38f1d9</Anchor>
    <Abstract>If set, the array is writeable (otherwise the buffer is read-only)</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>owndata</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>aa1ad8575ad6a6b900027c360a44e7ef0</Anchor>
    <Abstract>If set, the array owns the data (will be freed when the array is deleted)</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a7a8adf48e9a263af91aa975548e0e14d</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mutable_data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>ad06996f0b02fa6dc86e79744cbef5d80</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>offset_at</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a0063e6a1d118abb371f769377b5fee21</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>index_at</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a48d7b1bd08e0a5cf1ef27a6996421e73</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mutable_unchecked</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a93018344b9a8d27eacbdd7837f6efcab</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unchecked</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a453dfcd16f86df11e0a6ede98b04b7a0</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>squeeze</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>af0e9b034604a5306671cdb114855a972</Anchor>
    <Abstract>Return a new view with all of the dimensions of length 1 removed.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>resize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a3e03dfffbf6c992364c052cf615db45b</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ensure</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a4b19125eed75474c00a93c829dba3a8b</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>raw_array</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a1b059af39c8d296d72f31dcb4952cd4a</Anchor>
    <Abstract>Create array from any object â€“ always returns a new reference.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>array_caster</Scope>
    </TokenIdentifier>
    <Path>structarray__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_info</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>array_info</Scope>
    </TokenIdentifier>
    <Path>structarray__info.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_info&lt; char[N]&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>array_info&lt; char[N]&gt;</Scope>
    </TokenIdentifier>
    <Path>structarray__info_3_01char_0f_n_0e_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_info&lt; std::array&lt; char, N &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>array_info&lt; std::array&lt; char, N &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structarray__info_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_info&lt; std::array&lt; T, N &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>array_info&lt; std::array&lt; T, N &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structarray__info_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_info&lt; T[N]&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>array_info&lt; T[N]&gt;</Scope>
    </TokenIdentifier>
    <Path>structarray__info_3_01_t_0f_n_0e_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_info_scalar</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>array_info_scalar</Scope>
    </TokenIdentifier>
    <Path>structarray__info__scalar.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_t</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>array_t</Scope>
    </TokenIdentifier>
    <Path>classarray__t.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mutable_unchecked</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array_t</Scope>
    </TokenIdentifier>
    <Path>classarray__t.html</Path>
    <Anchor>a04bd133a0cfeab8df20d69b160027258</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unchecked</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array_t</Scope>
    </TokenIdentifier>
    <Path>classarray__t.html</Path>
    <Anchor>a97bf54c6d71ac61d4a8a311d49fc3dff</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dtype</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a49535f32396582e415a61f3aac9c78b3</Anchor>
    <Abstract>Array descriptor (dtype)</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>size</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a34ae467d17d30b99913e27c755403fef</Anchor>
    <Abstract>Total number of elements.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>itemsize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>acd6aa4dba1e1db26fcfd21a323b4d4fa</Anchor>
    <Abstract>Byte size of a single element.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nbytes</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a0a2a16579bf2918347a8762c03f10137</Anchor>
    <Abstract>Total number of bytes.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ndim</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a184360492eac7224753f132d1a0a973e</Anchor>
    <Abstract>Number of dimensions.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>base</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a33a2f2933da6ca35a8ac82709df90038</Anchor>
    <Abstract>Base object.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>shape</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a084781a3d2cb3ea60ab7bcf16c30ee31</Anchor>
    <Abstract>Dimensions of the array.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>shape</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>aceb118afe3a4eed2b3c9ec958505e414</Anchor>
    <Abstract>Dimension along a given axis.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>strides</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a3dd7d4e8f6d93e5714a642a3250df6e3</Anchor>
    <Abstract>Strides of the array.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>strides</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>afb8e09341f7884d6b34d454b2992c7ce</Anchor>
    <Abstract>Stride along a given axis.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>flags</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a38eb48c793621c12119ab7b64714955b</Anchor>
    <Abstract>Return the NumPy array flags.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>writeable</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a9c19f81ca43feebd34b2c9dd5b38f1d9</Anchor>
    <Abstract>If set, the array is writeable (otherwise the buffer is read-only)</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>owndata</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>aa1ad8575ad6a6b900027c360a44e7ef0</Anchor>
    <Abstract>If set, the array owns the data (will be freed when the array is deleted)</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a7a8adf48e9a263af91aa975548e0e14d</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mutable_data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>ad06996f0b02fa6dc86e79744cbef5d80</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>offset_at</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a0063e6a1d118abb371f769377b5fee21</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>index_at</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a48d7b1bd08e0a5cf1ef27a6996421e73</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mutable_unchecked</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a93018344b9a8d27eacbdd7837f6efcab</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unchecked</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a453dfcd16f86df11e0a6ede98b04b7a0</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>squeeze</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>af0e9b034604a5306671cdb114855a972</Anchor>
    <Abstract>Return a new view with all of the dimensions of length 1 removed.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>resize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a3e03dfffbf6c992364c052cf615db45b</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ensure</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>array_t</Scope>
    </TokenIdentifier>
    <Path>classarray__t.html</Path>
    <Anchor>a9e4404f6ad193d54f7354655823d3841</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ensure</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a4b19125eed75474c00a93c829dba3a8b</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>raw_array_t</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>array_t</Scope>
    </TokenIdentifier>
    <Path>classarray__t.html</Path>
    <Anchor>a49bc4cbb7ac30eb5ddbfa8df992d897d</Anchor>
    <Abstract>Create array from any object â€“ always returns a new reference.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>raw_array</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>array</Scope>
    </TokenIdentifier>
    <Path>classarray.html</Path>
    <Anchor>a1b059af39c8d296d72f31dcb4952cd4a</Anchor>
    <Abstract>Create array from any object â€“ always returns a new reference.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>array_t::private_ctor</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>array_t::private_ctor</Scope>
    </TokenIdentifier>
    <Path>structarray__t_1_1private__ctor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ArrayStruct</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ArrayStruct</Scope>
    </TokenIdentifier>
    <Path>struct_array_struct.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>arrow_proxy</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>arrow_proxy</Scope>
    </TokenIdentifier>
    <Path>structarrow__proxy.html</Path>
    <Abstract>Quick proxy class needed to implement operator-&gt; for iterators which can&apos;t return pointers.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>B</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>B</Scope>
    </TokenIdentifier>
    <Path>struct_b.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>B_Repeat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>B_Repeat</Scope>
    </TokenIdentifier>
    <Path>class_b___repeat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>B_Tpl</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>B_Tpl</Scope>
    </TokenIdentifier>
    <Path>class_b___tpl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>base</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>base</Scope>
    </TokenIdentifier>
    <Path>structbase.html</Path>
    <Abstract>Annotation indicating that a class derives from another given type.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Base</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Base</Scope>
    </TokenIdentifier>
    <Path>struct_base.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>BaseN</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>BaseN</Scope>
    </TokenIdentifier>
    <Path>struct_base_n.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>bool_</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>bool_</Scope>
    </TokenIdentifier>
    <Path>classbool__.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>raw_bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>bool_</Scope>
    </TokenIdentifier>
    <Path>classbool__.html</Path>
    <Anchor>ab999c1dc80d5fcdd252399467afe0d09</Anchor>
    <Abstract>Return the truth value of an object â€“ always returns a new reference.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>bools</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>bools</Scope>
    </TokenIdentifier>
    <Path>structbools.html</Path>
    <Abstract>Compile-time all/any/none of that check the boolean value of all template types.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>BreaksBase</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>BreaksBase</Scope>
    </TokenIdentifier>
    <Path>class_breaks_base.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>BreaksTramp</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>BreaksTramp</Scope>
    </TokenIdentifier>
    <Path>class_breaks_tramp.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>buffer</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>buffer</Scope>
    </TokenIdentifier>
    <Path>classbuffer.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>buffer_info</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>buffer_info</Scope>
    </TokenIdentifier>
    <Path>structbuffer__info.html</Path>
    <Abstract>Information record describing a Python buffer object.</Abstract>
    <DeclaredIn>buffer_info.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>buffer_info::private_ctr_tag</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>buffer_info::private_ctr_tag</Scope>
    </TokenIdentifier>
    <Path>structbuffer__info_1_1private__ctr__tag.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>buffer_protocol</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>buffer_protocol</Scope>
    </TokenIdentifier>
    <Path>structbuffer__protocol.html</Path>
    <Abstract>Annotation which enables the buffer protocol for a type.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>builtin_exception</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>builtin_exception</Scope>
    </TokenIdentifier>
    <Path>classbuiltin__exception.html</Path>
    <Abstract>C++ bindings of builtin Python exceptions.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>set_error</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>builtin_exception</Scope>
    </TokenIdentifier>
    <Path>classbuiltin__exception.html</Path>
    <Anchor>a1a12a564ae0fd4687e2f491c36d1133b</Anchor>
    <Abstract>Set the error using the Python C API.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>bytes</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>bytes</Scope>
    </TokenIdentifier>
    <Path>classbytes.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>C1</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>C1</Scope>
    </TokenIdentifier>
    <Path>class_c1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>C2</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>C2</Scope>
    </TokenIdentifier>
    <Path>class_c2.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>C_Repeat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>C_Repeat</Scope>
    </TokenIdentifier>
    <Path>class_c___repeat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>C_Tpl</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>C_Tpl</Scope>
    </TokenIdentifier>
    <Path>class_c___tpl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>call_guard</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>call_guard</Scope>
    </TokenIdentifier>
    <Path>structcall__guard.html</Path>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>call_guard&lt; T &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>call_guard&lt; T &gt;</Scope>
    </TokenIdentifier>
    <Path>structcall__guard_3_01_t_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>call_guard&lt; T, Ts... &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>call_guard&lt; T, Ts... &gt;</Scope>
    </TokenIdentifier>
    <Path>structcall__guard_3_01_t_00_01_ts_8_8_8_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>call_guard&lt; T, Ts... &gt;::type</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>call_guard&lt; T, Ts... &gt;::type</Scope>
    </TokenIdentifier>
    <Path>structcall__guard_3_01_t_00_01_ts_8_8_8_01_4_1_1type.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>call_guard&lt;&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>call_guard&lt;&gt;</Scope>
    </TokenIdentifier>
    <Path>structcall__guard_3_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>capsule</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>capsule</Scope>
    </TokenIdentifier>
    <Path>classcapsule.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Cat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Cat</Scope>
    </TokenIdentifier>
    <Path>struct_cat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Chihuahua</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Chihuahua</Scope>
    </TokenIdentifier>
    <Path>struct_chihuahua.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>class_</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_readonly</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a0b005f5ca971191308806807682cdf94</Anchor>
    <Abstract>Uses return_value_policy::reference_internal by default.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_readonly</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>ac7f87d627ffe20ca113b2c42eb746d45</Anchor>
    <Abstract>Uses cpp_function&apos;s return_value_policy by default.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_readonly_static</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>afa89332683e8e7e134472d5dc83ba6b3</Anchor>
    <Abstract>Uses return_value_policy::reference by default.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_readonly_static</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a84efdefa8be30cf8fe803793474430c1</Anchor>
    <Abstract>Uses cpp_function&apos;s return_value_policy by default.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a2f2cd90a7ae2f7895e0b0caadac82f6f</Anchor>
    <Abstract>Uses return_value_policy::reference_internal by default.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>ab976d0a595ac11629949c1faa8b2e09d</Anchor>
    <Abstract>Uses cpp_function&apos;s return_value_policy by default.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_static</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>ab78c60e008d354283f76eef3b7c6e221</Anchor>
    <Abstract>Uses return_value_policy::reference by default.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_static</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a1c2c3cfa3f7ba78fcb344a716dcc59a3</Anchor>
    <Abstract>Uses cpp_function&apos;s return_value_policy by default.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init_holder</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a0b9fc3852fd1fd8959fa58f3a9d9b92f</Anchor>
    <Abstract>Initialize holder object, variant 1: object derives from enable_shared_from_this.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init_holder</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>adeece97080849a4a259d82c5bf3a7a8e</Anchor>
    <Abstract>Initialize holder object, variant 2: try to construct from existing holder object,...</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init_instance</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a20391d006c3476cc8f0317a7e82dccfe</Anchor>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dealloc</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>class_</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a6b1260e369fcbc36da23cc813c88d163</Anchor>
    <Abstract>Deallocates an instance; via holder, if constructed; otherwise via operator delete.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>class_::is_valid_class_option</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>class_::is_valid_class_option</Scope>
    </TokenIdentifier>
    <Path>structclass___1_1is__valid__class__option.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>common_iterator</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>common_iterator</Scope>
    </TokenIdentifier>
    <Path>classcommon__iterator.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compare_buffer_info</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>compare_buffer_info</Scope>
    </TokenIdentifier>
    <Path>structcompare__buffer__info.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compare_buffer_info&lt; T, detail::enable_if_t&lt; detail::is_pod_struct&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>compare_buffer_info&lt; T, detail::enable_if_t&lt; detail::is_pod_struct&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structcompare__buffer__info_3_01_t_00_01detail_1_1enable__if__t_3_01detail_1_1is__pod__struct_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compare_buffer_info&lt; T, detail::enable_if_t&lt; std::is_integral&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>compare_buffer_info&lt; T, detail::enable_if_t&lt; std::is_integral&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structcompare__buffer__info_3_01_t_00_01detail_1_1enable__if__t_3_01std_1_1is__integral_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ComplexStruct</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ComplexStruct</Scope>
    </TokenIdentifier>
    <Path>struct_complex_struct.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>constructor</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>constructor</Scope>
    </TokenIdentifier>
    <Path>structconstructor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ConstructorStats</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ConstructorStats</Scope>
    </TokenIdentifier>
    <Path>class_constructor_stats.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>container_traits</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>container_traits</Scope>
    </TokenIdentifier>
    <Path>structcontainer__traits.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>copyable_holder_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>copyable_holder_caster</Scope>
    </TokenIdentifier>
    <Path>structcopyable__holder__caster.html</Path>
    <Abstract>Type caster for holder types like std::shared_ptr, etc.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>try_load_foreign_module_local</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>type_caster_generic</Scope>
    </TokenIdentifier>
    <Path>classtype__caster__generic.html</Path>
    <Anchor>a9e76e336b90a56185b35d47c34aeecd7</Anchor>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>CopyOnlyInt</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>CopyOnlyInt</Scope>
    </TokenIdentifier>
    <Path>class_copy_only_int.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cpp_function</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Abstract>Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cpp_function</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>adf288fd4fadeaf8e9e142d177fc267da</Anchor>
    <Abstract>Construct a cpp_function from a vanilla function pointer.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cpp_function</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>a345da213151996cb60ba487622036899</Anchor>
    <Abstract>Construct a cpp_function from a lambda function (possibly with internal state)</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cpp_function</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>a977ae047c5ece21dbfbbccda8c304986</Anchor>
    <Abstract>Construct a cpp_function from a class method (non-const, no ref-qualifier)</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cpp_function</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>a39b3d7409bf650791c032480e81e5740</Anchor>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cpp_function</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>adf1a5ad6ed0992a0bd07c2048b98d6f1</Anchor>
    <Abstract>Construct a cpp_function from a class method (const, no ref-qualifier)</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cpp_function</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>acf85d6a21fa9bbdbef4f9ae71d8936bf</Anchor>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>name</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>a5d8bcdd6781aa6da434299589c68013e</Anchor>
    <Abstract>Return the function name.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>make_function_record</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>a7d2049a6916365d7d7de982d574e2f3c</Anchor>
    <Abstract>Space optimization: don&apos;t inline this frequently instantiated fragment.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>initialize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>a97487e306e9e0a8d0535fb5fe5c6d8ef</Anchor>
    <Abstract>Special internal constructor for functors, lambda functions, etc.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>initialize_generic</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>a4120dff5c867829edb5ad1df929ec522</Anchor>
    <Abstract>Register a function call with Python (generic non-templated code goes here)</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>destruct</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>a61bdafab94b0fa0bad23c5161e7f9e59</Anchor>
    <Abstract>When a cpp_function is GCed, release any memory allocated by pybind11.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dispatcher</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>cpp_function</Scope>
    </TokenIdentifier>
    <Path>classcpp__function.html</Path>
    <Anchor>ab1792b64255d0159f38853a6d8f508bb</Anchor>
    <Abstract>Main dispatch logic for calls to functions bound using pybind11.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>custom_unique_ptr</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>custom_unique_ptr</Scope>
    </TokenIdentifier>
    <Path>classcustom__unique__ptr.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>CustomGuard</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>CustomGuard</Scope>
    </TokenIdentifier>
    <Path>struct_custom_guard.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>CustomOperatorNew</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>CustomOperatorNew</Scope>
    </TokenIdentifier>
    <Path>struct_custom_operator_new.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>D_Repeat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>D_Repeat</Scope>
    </TokenIdentifier>
    <Path>class_d___repeat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>D_Tpl</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>D_Tpl</Scope>
    </TokenIdentifier>
    <Path>class_d___tpl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>deferred_type</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>deferred_type</Scope>
    </TokenIdentifier>
    <Path>structdeferred__type.html</Path>
    <Abstract>Defer the evaluation of type T until types Us are instantiated.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>DependentGuard</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>DependentGuard</Scope>
    </TokenIdentifier>
    <Path>struct_dependent_guard.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>descr</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>descr</Scope>
    </TokenIdentifier>
    <Path>structdescr.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>DestructionTester</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>DestructionTester</Scope>
    </TokenIdentifier>
    <Path>class_destruction_tester.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dict</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>dict</Scope>
    </TokenIdentifier>
    <Path>classdict.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>raw_dict</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>dict</Scope>
    </TokenIdentifier>
    <Path>classdict.html</Path>
    <Anchor>a1f7f76b081a8f193549ddf7b43aa1b89</Anchor>
    <Abstract>Call the dict Python type â€“ always returns a new reference.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dict_readonly</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>dict_readonly</Scope>
    </TokenIdentifier>
    <Path>classdict__readonly.html</Path>
    <Abstract>Python&apos;s dictionary protocol permits this to be a forward iterator.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>DispatchIssue</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>DispatchIssue</Scope>
    </TokenIdentifier>
    <Path>struct_dispatch_issue.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>doc</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>doc</Scope>
    </TokenIdentifier>
    <Path>structdoc.html</Path>
    <Abstract>Annotation for documentation.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Dog</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Dog</Scope>
    </TokenIdentifier>
    <Path>struct_dog.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dtype</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>dtype</Scope>
    </TokenIdentifier>
    <Path>classdtype.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>itemsize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>dtype</Scope>
    </TokenIdentifier>
    <Path>classdtype.html</Path>
    <Anchor>a7560e2e9cd37d8dd697755e58442e4cb</Anchor>
    <Abstract>Size of the data type in bytes.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_fields</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>dtype</Scope>
    </TokenIdentifier>
    <Path>classdtype.html</Path>
    <Anchor>ac5eef3474b98106df8be32c6aaa3106b</Anchor>
    <Abstract>Returns true for structured data types.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>kind</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>dtype</Scope>
    </TokenIdentifier>
    <Path>classdtype.html</Path>
    <Anchor>a18ed8c10011953681620744776e2c984</Anchor>
    <Abstract>Single-character type code.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>from_args</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>dtype</Scope>
    </TokenIdentifier>
    <Path>classdtype.html</Path>
    <Anchor>ac32ee9257455ed7879d124fb225b0baa</Anchor>
    <Abstract>This is essentially the same as calling numpy.dtype(args) in Python.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>of</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>dtype</Scope>
    </TokenIdentifier>
    <Path>classdtype.html</Path>
    <Anchor>a06f34b2e5cc8a17f7038e870b9609191</Anchor>
    <Abstract>Return dtype associated with a C++ type.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>DtypeCheck</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>DtypeCheck</Scope>
    </TokenIdentifier>
    <Path>struct_dtype_check.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>DtypeSizeCheck</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>DtypeSizeCheck</Scope>
    </TokenIdentifier>
    <Path>struct_dtype_size_check.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>duration_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>duration_caster</Scope>
    </TokenIdentifier>
    <Path>classduration__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dynamic_attr</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>dynamic_attr</Scope>
    </TokenIdentifier>
    <Path>structdynamic__attr.html</Path>
    <Abstract>Annotation which enables dynamic attributes, i.e. adds __dict__ to a class.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>E_nc</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>E_nc</Scope>
    </TokenIdentifier>
    <Path>class_e__nc.html</Path>
    <Abstract>Issue #487: binding std::vector&lt;E&gt; with E non-copyable.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>eigen_extract_stride</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>eigen_extract_stride</Scope>
    </TokenIdentifier>
    <Path>structeigen__extract__stride.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>eigen_extract_stride&lt; Eigen::Map&lt; PlainObjectType, MapOptions, StrideType &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>eigen_extract_stride&lt; Eigen::Map&lt; PlainObjectType, MapOptions, StrideType &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structeigen__extract__stride_3_01_eigen_1_1_map_3_01_plain_object_type_00_01_map_options_00_01_stride_type_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>eigen_extract_stride&lt; Eigen::Ref&lt; PlainObjectType, Options, StrideType &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>eigen_extract_stride&lt; Eigen::Ref&lt; PlainObjectType, Options, StrideType &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structeigen__extract__stride_3_01_eigen_1_1_ref_3_01_plain_object_type_00_01_options_00_01_stride_type_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>eigen_map_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>eigen_map_caster</Scope>
    </TokenIdentifier>
    <Path>structeigen__map__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>EigenConformable</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>EigenConformable</Scope>
    </TokenIdentifier>
    <Path>struct_eigen_conformable.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>EigenProps</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>EigenProps</Scope>
    </TokenIdentifier>
    <Path>struct_eigen_props.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>El</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>El</Scope>
    </TokenIdentifier>
    <Path>class_el.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>embedded_module</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>embedded_module</Scope>
    </TokenIdentifier>
    <Path>structembedded__module.html</Path>
    <Abstract>Python 2.7/3.x compatible version of PyImport_AppendInittab and error checks.</Abstract>
    <DeclaredIn>embed.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>empty</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>empty</Scope>
    </TokenIdentifier>
    <Path>structempty.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>enum_</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>enum_</Scope>
    </TokenIdentifier>
    <Path>classenum__.html</Path>
    <Abstract>Binds C++ enumerations and enumeration classes to Python.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>export_values</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>enum_</Scope>
    </TokenIdentifier>
    <Path>classenum__.html</Path>
    <Anchor>a1cb0d14e870b83cd87bd1f9846b9a449</Anchor>
    <Abstract>Export enumeration entries into the parent scope.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>value</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>enum_</Scope>
    </TokenIdentifier>
    <Path>classenum__.html</Path>
    <Anchor>a4fae60a7877648a70512ea627dc24b12</Anchor>
    <Abstract>Add an enumeration entry.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_readonly</Name>
      <APILanguage>unknown</APILanguage>
      <Type>instm</Type>
      <Scope>class_&lt; Type &gt;</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a0b005f5ca971191308806807682cdf94</Anchor>
    <Abstract>Uses return_value_policy::reference_internal by default.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_readonly</Name>
      <APILanguage>unknown</APILanguage>
      <Type>instm</Type>
      <Scope>class_&lt; Type &gt;</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>ac7f87d627ffe20ca113b2c42eb746d45</Anchor>
    <Abstract>Uses cpp_function&apos;s return_value_policy by default.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_readonly_static</Name>
      <APILanguage>unknown</APILanguage>
      <Type>instm</Type>
      <Scope>class_&lt; Type &gt;</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>afa89332683e8e7e134472d5dc83ba6b3</Anchor>
    <Abstract>Uses return_value_policy::reference by default.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_readonly_static</Name>
      <APILanguage>unknown</APILanguage>
      <Type>instm</Type>
      <Scope>class_&lt; Type &gt;</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a84efdefa8be30cf8fe803793474430c1</Anchor>
    <Abstract>Uses cpp_function&apos;s return_value_policy by default.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property</Name>
      <APILanguage>unknown</APILanguage>
      <Type>instm</Type>
      <Scope>class_&lt; Type &gt;</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a2f2cd90a7ae2f7895e0b0caadac82f6f</Anchor>
    <Abstract>Uses return_value_policy::reference_internal by default.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property</Name>
      <APILanguage>unknown</APILanguage>
      <Type>instm</Type>
      <Scope>class_&lt; Type &gt;</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>ab976d0a595ac11629949c1faa8b2e09d</Anchor>
    <Abstract>Uses cpp_function&apos;s return_value_policy by default.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_static</Name>
      <APILanguage>unknown</APILanguage>
      <Type>instm</Type>
      <Scope>class_&lt; Type &gt;</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>ab78c60e008d354283f76eef3b7c6e221</Anchor>
    <Abstract>Uses return_value_policy::reference by default.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_property_static</Name>
      <APILanguage>unknown</APILanguage>
      <Type>instm</Type>
      <Scope>class_&lt; Type &gt;</Scope>
    </TokenIdentifier>
    <Path>classclass__.html</Path>
    <Anchor>a1c2c3cfa3f7ba78fcb344a716dcc59a3</Anchor>
    <Abstract>Uses cpp_function&apos;s return_value_policy by default.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>enum_base</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>enum_base</Scope>
    </TokenIdentifier>
    <Path>structenum__base.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error_already_set</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>error_already_set</Scope>
    </TokenIdentifier>
    <Path>classerror__already__set.html</Path>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error_already_set</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>error_already_set</Scope>
    </TokenIdentifier>
    <Path>classerror__already__set.html</Path>
    <Anchor>a9f6456fb9f03460d943682037132e819</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>restore</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>error_already_set</Scope>
    </TokenIdentifier>
    <Path>classerror__already__set.html</Path>
    <Anchor>a751b231e5c796447d867cf30007a7fc0</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>matches</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>error_already_set</Scope>
    </TokenIdentifier>
    <Path>classerror__already__set.html</Path>
    <Anchor>a6585d62b1153c401745df155a7c87f6f</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error_scope</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>error_scope</Scope>
    </TokenIdentifier>
    <Path>structerror__scope.html</Path>
    <Abstract>RAII wrapper that temporarily clears any Python error state.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>exactly_one</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>exactly_one</Scope>
    </TokenIdentifier>
    <Path>structexactly__one.html</Path>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>exactly_one&lt; P, Default &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>exactly_one&lt; P, Default &gt;</Scope>
    </TokenIdentifier>
    <Path>structexactly__one_3_01_p_00_01_default_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ExampleMandA</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ExampleMandA</Scope>
    </TokenIdentifier>
    <Path>class_example_mand_a.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ExampleVirt</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ExampleVirt</Scope>
    </TokenIdentifier>
    <Path>class_example_virt.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>exception</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>exception</Scope>
    </TokenIdentifier>
    <Path>classexception.html</Path>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>factory</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>factory</Scope>
    </TokenIdentifier>
    <Path>structfactory.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>factory&lt; CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>factory&lt; CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)&gt;</Scope>
    </TokenIdentifier>
    <Path>structfactory_3_01_c_func_00_01_a_func_00_01_c_return_07_c_args_8_8_8_08_00_01_a_return_07_a_args_8_8_8_08_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>factory&lt; Func, void_type(*)(), Return(Args...)&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>factory&lt; Func, void_type(*)(), Return(Args...)&gt;</Scope>
    </TokenIdentifier>
    <Path>structfactory_3_01_func_00_01void__type_07_5_08_07_08_00_01_return_07_args_8_8_8_08_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>field_descriptor</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>field_descriptor</Scope>
    </TokenIdentifier>
    <Path>structfield__descriptor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>float_</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>float_</Scope>
    </TokenIdentifier>
    <Path>classfloat__.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>format_descriptor</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>format_descriptor</Scope>
    </TokenIdentifier>
    <Path>structformat__descriptor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>format_descriptor&lt; char[N]&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>format_descriptor&lt; char[N]&gt;</Scope>
    </TokenIdentifier>
    <Path>structformat__descriptor_3_01char_0f_n_0e_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>format_descriptor&lt; std::array&lt; char, N &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>format_descriptor&lt; std::array&lt; char, N &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structformat__descriptor_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>format_descriptor&lt; std::complex&lt; T &gt;, detail::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>format_descriptor&lt; std::complex&lt; T &gt;, detail::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structformat__descriptor_3_01std_1_1complex_3_01_t_01_4_00_01detail_1_1enable__if__t_3_01std_1_183b0c7485f88e97534b116276abc2578.html</Path>
    <Abstract>glibc defines I as a macro which breaks things, e.g., boost template names</Abstract>
    <DeclaredIn>complex.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>format_descriptor&lt; T, detail::enable_if_t&lt; detail::array_info&lt; T &gt;::is_array &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>format_descriptor&lt; T, detail::enable_if_t&lt; detail::array_info&lt; T &gt;::is_array &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structformat__descriptor_3_01_t_00_01detail_1_1enable__if__t_3_01detail_1_1array__info_3_01_t_01_4_1_1is__array_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>format_descriptor&lt; T, detail::enable_if_t&lt; detail::is_pod_struct&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>format_descriptor&lt; T, detail::enable_if_t&lt; detail::is_pod_struct&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structformat__descriptor_3_01_t_00_01detail_1_1enable__if__t_3_01detail_1_1is__pod__struct_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>format_descriptor&lt; T, detail::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>format_descriptor&lt; T, detail::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structformat__descriptor_3_01_t_00_01detail_1_1enable__if__t_3_01std_1_1is__arithmetic_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>format_descriptor&lt; T, detail::enable_if_t&lt; std::is_enum&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>format_descriptor&lt; T, detail::enable_if_t&lt; std::is_enum&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structformat__descriptor_3_01_t_00_01detail_1_1enable__if__t_3_01std_1_1is__enum_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>function</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>function</Scope>
    </TokenIdentifier>
    <Path>classfunction.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>function_call</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>function_call</Scope>
    </TokenIdentifier>
    <Path>structfunction__call.html</Path>
    <Abstract>Internal data associated with a single function call.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>func</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_call</Scope>
    </TokenIdentifier>
    <Path>structfunction__call.html</Path>
    <Anchor>afadf98c8478fd2c1958003cedefa38d7</Anchor>
    <Abstract>The function data:</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>args</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_call</Scope>
    </TokenIdentifier>
    <Path>structfunction__call.html</Path>
    <Anchor>ae77a8a65a8ae5ebbbd2eb17bc9ff54d3</Anchor>
    <Abstract>Arguments passed to the function:</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>args_convert</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_call</Scope>
    </TokenIdentifier>
    <Path>structfunction__call.html</Path>
    <Anchor>aef756a1f9206af0d2e3fdb684b2d6b5f</Anchor>
    <Abstract>The convert value the arguments should be loaded with.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>args_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_call</Scope>
    </TokenIdentifier>
    <Path>structfunction__call.html</Path>
    <Anchor>a13ff878b84d1c7a41c0f28c62db36925</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>parent</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_call</Scope>
    </TokenIdentifier>
    <Path>structfunction__call.html</Path>
    <Anchor>a72923821447a70a799f862a501eee20d</Anchor>
    <Abstract>The parent, if any.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init_self</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_call</Scope>
    </TokenIdentifier>
    <Path>structfunction__call.html</Path>
    <Anchor>a8f9e4659cf3ca4be507d2220420b9c00</Anchor>
    <Abstract>If this is a call to an initializer, this argument contains self</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>function_record</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Abstract>Internal data structure which holds metadata about a bound function (signature, overloads,...</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>name</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a55d760eb0046c3beec8a20d94ed1d07c</Anchor>
    <Abstract>Function name.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>signature</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>aed1e3374bb684af2676d1aeb457c65b5</Anchor>
    <Abstract>Human-readable version of the function signature.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>args</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>abc060d33223e10553cb15c879e326ef5</Anchor>
    <Abstract>List of registered keyword arguments.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>impl</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a0e6a4fd6fef173a1958f8c14c6610ac9</Anchor>
    <Abstract>Pointer to lambda function which converts arguments and performs the actual call.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>ada09f0077964b216ba0bf9c12cb6c25f</Anchor>
    <Abstract>Storage for the wrapped function pointer and captured data, if any.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>free_data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>aa3019482c3aba125c05edf641d557576</Anchor>
    <Abstract>Pointer to custom destructor for &apos;data&apos; (if needed)</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>policy</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a27926b7355bd89048ff5da97758b5282</Anchor>
    <Abstract>Return value policy associated with this function.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_constructor</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>aa014e3469d353ed93ffb67d626879a29</Anchor>
    <Abstract>True if name == &apos;init&apos;.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_new_style_constructor</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a2a002c9d435634209613d4be9f3d5d7c</Anchor>
    <Abstract>True if this is a new-style __init__ defined in detail/init.h</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_stateless</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>abdee0c594dc06ef0b4d4b136255ea971</Anchor>
    <Abstract>True if this is a stateless function pointer.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_operator</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>ab57608549c3d2c71771feda7808a2595</Anchor>
    <Abstract>True if this is an operator (add), etc.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_method</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>aaad664f057b3151927053a855ec3aea0</Anchor>
    <Abstract>True if this is a method.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_args</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>af05b5fc3d6d3b5bcec45bbd1c3e75f15</Anchor>
    <Abstract>True if the function has a &apos;*args&apos; argument.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_kwargs</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>af72350bd8c047108e403ff873c0a1f7d</Anchor>
    <Abstract>True if the function has a &apos;**kwargs&apos; argument.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_kwonly_args</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>aa772e2a834c7250586a1c919070e8efb</Anchor>
    <Abstract>True once a &apos;py::kwonly&apos; is encountered (any following args are keyword-only)</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nargs</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a8082876641e039386647a6b6b5118d41</Anchor>
    <Abstract>Number of arguments (including py::args and/or py::kwargs, if present)</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nargs_kwonly</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a7f8c75b6945042ec66be7a941c3971d7</Anchor>
    <Abstract>Number of trailing arguments (counted in nargs) that are keyword-only.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a3297bc630d16b17a5559025615390ffa</Anchor>
    <Abstract>Python method object.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scope</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>ad4112e6eb003c64f181968b2759a08af</Anchor>
    <Abstract>Python handle to the parent scope (a class or a module)</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sibling</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a647a4421f0491047b6ea680efd2c0e45</Anchor>
    <Abstract>Python handle to the sibling function representing an overload chain.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>next</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>function_record</Scope>
    </TokenIdentifier>
    <Path>structfunction__record.html</Path>
    <Anchor>a141b30999d54286b04d06ad6180dbf99</Anchor>
    <Abstract>Pointer to next overload.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>generic_item</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>generic_item</Scope>
    </TokenIdentifier>
    <Path>structgeneric__item.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>generic_iterator</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>generic_iterator</Scope>
    </TokenIdentifier>
    <Path>classgeneric__iterator.html</Path>
    <Abstract>STL iterator template used for tuple, list, sequence and dict.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>generic_type</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>generic_type</Scope>
    </TokenIdentifier>
    <Path>classgeneric__type.html</Path>
    <Abstract>Generic support for creating new Python heap types.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mark_parents_nonsimple</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>generic_type</Scope>
    </TokenIdentifier>
    <Path>classgeneric__type.html</Path>
    <Anchor>aa102cbe989b604345c02dcd821f6c5b2</Anchor>
    <Abstract>Helper function which tags all parents of a type using mult. inheritance.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>gil_scoped_acquire</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>gil_scoped_acquire</Scope>
    </TokenIdentifier>
    <Path>classgil__scoped__acquire.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>gil_scoped_release</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>gil_scoped_release</Scope>
    </TokenIdentifier>
    <Path>classgil__scoped__release.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>handle_type_name</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name&lt; args &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>handle_type_name&lt; args &gt;</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name_3_01args_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name&lt; array &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>handle_type_name&lt; array &gt;</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name_3_01array_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name&lt; array_t&lt; T, Flags &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>handle_type_name&lt; array_t&lt; T, Flags &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name_3_01array__t_3_01_t_00_01_flags_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name&lt; bytes &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>handle_type_name&lt; bytes &gt;</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name_3_01bytes_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name&lt; int_ &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>handle_type_name&lt; int_ &gt;</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name_3_01int___01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name&lt; iterable &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>handle_type_name&lt; iterable &gt;</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name_3_01iterable_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name&lt; iterator &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>handle_type_name&lt; iterator &gt;</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name_3_01iterator_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle_type_name&lt; kwargs &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>handle_type_name&lt; kwargs &gt;</Scope>
    </TokenIdentifier>
    <Path>structhandle__type__name_3_01kwargs_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_operator_delete</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>has_operator_delete</Scope>
    </TokenIdentifier>
    <Path>structhas__operator__delete.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_operator_delete&lt; T, void_t&lt; decltype(static_cast&lt; void(*)(void *)&gt;(T::operator delete))&gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>has_operator_delete&lt; T, void_t&lt; decltype(static_cast&lt; void(*)(void *)&gt;(T::operator delete))&gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structhas__operator__delete_3_01_t_00_01void__t_3_01decltype_07static__cast_3_01void_07_5_08_07vbad95f4ce94079b9ba36252dd72d93b5.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_operator_delete_size</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>has_operator_delete_size</Scope>
    </TokenIdentifier>
    <Path>structhas__operator__delete__size.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_operator_delete_size&lt; T, void_t&lt; decltype(static_cast&lt; void(*)(void *, size_t)&gt;(T::operator delete))&gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>has_operator_delete_size&lt; T, void_t&lt; decltype(static_cast&lt; void(*)(void *, size_t)&gt;(T::operator delete))&gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structhas__operator__delete__size_3_01_t_00_01void__t_3_01decltype_07static__cast_3_01void_07_5_e659cd67a562b6670920a523a8edb40c.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>holder_helper</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>holder_helper</Scope>
    </TokenIdentifier>
    <Path>structholder__helper.html</Path>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>huge_unique_ptr</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>huge_unique_ptr</Scope>
    </TokenIdentifier>
    <Path>classhuge__unique__ptr.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>IncType</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>IncType</Scope>
    </TokenIdentifier>
    <Path>class_inc_type.html</Path>
    <Abstract>Like UserType, but increments value on copy for quick reference vs. copy tests.</Abstract>
    <DeclaredIn>pybind11_tests.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>index_sequence</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>index_sequence</Scope>
    </TokenIdentifier>
    <Path>structindex__sequence.html</Path>
    <Abstract>Index sequences.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>instance</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Abstract>The &apos;instance&apos; type which needs to be standard layout (need to be able to use &apos;offsetof&apos;)</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>allocate_layout</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>addb02b48487bafc757c28d40d1d6a995</Anchor>
    <Abstract>Initializes all of the above type/values/holders data (but not the instance values themselves)</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>deallocate_layout</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a0e6db8a0edd9f4d440a4b31fb1f59d19</Anchor>
    <Abstract>Destroys/deallocates all of the above.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get_value_and_holder</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a33fb0acd9a08898baf6dfefc54477821</Anchor>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>weakrefs</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a23dd4c6144dbfa8ed0ba6d2a7a964998</Anchor>
    <Abstract>Weak references.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>owned</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a69b3e638c182ecbbaaa5625ce3c36e99</Anchor>
    <Abstract>If true, the pointer is owned which means we&apos;re free to manage it with a holder.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>simple_layout</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a1e23897fd281cdd5cecd2d36b5d7a26d</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>simple_holder_constructed</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a70b19567d7738df6679e1599e7d3ff75</Anchor>
    <Abstract>For simple layout, tracks whether the holder has been constructed.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>simple_instance_registered</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a464df414f8c21853c43be0ab4ccf8e93</Anchor>
    <Abstract>For simple layout, tracks whether the instance is registered in registered_instances</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>has_patients</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a30d2da1bf481e5628e3f20a84a4bcd1a</Anchor>
    <Abstract>If true, get_internals().patients has an entry for this object.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>status_holder_constructed</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>instance</Scope>
    </TokenIdentifier>
    <Path>structinstance.html</Path>
    <Anchor>a2d8ccf4b4d7dcb8083cee8cc030ec871</Anchor>
    <Abstract>Bit values for the non-simple status flags.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>int_</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>int_</Scope>
    </TokenIdentifier>
    <Path>classint__.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>int_to_str</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>int_to_str</Scope>
    </TokenIdentifier>
    <Path>structint__to__str.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>int_to_str&lt; 0, Digits... &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>int_to_str&lt; 0, Digits... &gt;</Scope>
    </TokenIdentifier>
    <Path>structint__to__str_3_010_00_01_digits_8_8_8_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>internals</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>internals</Scope>
    </TokenIdentifier>
    <Path>structinternals.html</Path>
    <DeclaredIn>internals.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>intrinsic_type</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>intrinsic_type</Scope>
    </TokenIdentifier>
    <Path>structintrinsic__type.html</Path>
    <Abstract>Helper template to strip away type modifiers.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>intrinsic_type&lt; const T &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>intrinsic_type&lt; const T &gt;</Scope>
    </TokenIdentifier>
    <Path>structintrinsic__type_3_01const_01_t_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>intrinsic_type&lt; const T[N]&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>intrinsic_type&lt; const T[N]&gt;</Scope>
    </TokenIdentifier>
    <Path>structintrinsic__type_3_01const_01_t_0f_n_0e_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>intrinsic_type&lt; T &amp; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>intrinsic_type&lt; T &amp; &gt;</Scope>
    </TokenIdentifier>
    <Path>structintrinsic__type_3_01_t_01_6_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>intrinsic_type&lt; T &amp;&amp; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>intrinsic_type&lt; T &amp;&amp; &gt;</Scope>
    </TokenIdentifier>
    <Path>structintrinsic__type_3_01_t_01_6_6_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>intrinsic_type&lt; T * &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>intrinsic_type&lt; T * &gt;</Scope>
    </TokenIdentifier>
    <Path>structintrinsic__type_3_01_t_01_5_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>intrinsic_type&lt; T[N]&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>intrinsic_type&lt; T[N]&gt;</Scope>
    </TokenIdentifier>
    <Path>structintrinsic__type_3_01_t_0f_n_0e_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_comparable</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_comparable</Scope>
    </TokenIdentifier>
    <Path>structis__comparable.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_comparable&lt; T, enable_if_t&lt; container_traits&lt; T &gt;::is_element &amp;&amp;container_traits&lt; T &gt;::is_comparable &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_comparable&lt; T, enable_if_t&lt; container_traits&lt; T &gt;::is_element &amp;&amp;container_traits&lt; T &gt;::is_comparable &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__comparable_3_01_t_00_01enable__if__t_3_01container__traits_3_01_t_01_4_1_1is__element_81dba1096c4a7c2c4f27f8f67bb7d966.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_comparable&lt; T, enable_if_t&lt; container_traits&lt; T &gt;::is_pair &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_comparable&lt; T, enable_if_t&lt; container_traits&lt; T &gt;::is_pair &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__comparable_3_01_t_00_01enable__if__t_3_01container__traits_3_01_t_01_4_1_1is__pair_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_comparable&lt; T, enable_if_t&lt; container_traits&lt; T &gt;::is_vector &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_comparable&lt; T, enable_if_t&lt; container_traits&lt; T &gt;::is_vector &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__comparable_3_01_t_00_01enable__if__t_3_01container__traits_3_01_t_01_4_1_1is__vector_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_complex</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_complex</Scope>
    </TokenIdentifier>
    <Path>structis__complex.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_complex&lt; std::complex&lt; T &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_complex&lt; std::complex&lt; T &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__complex_3_01std_1_1complex_3_01_t_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_copy_assignable</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_copy_assignable</Scope>
    </TokenIdentifier>
    <Path>structis__copy__assignable.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_copy_assignable&lt; Container, enable_if_t&lt; all_of&lt; std::is_copy_assignable&lt; Container &gt;, std::is_same&lt; typename Container::value_type &amp;, typename Container::reference &gt; &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_copy_assignable&lt; Container, enable_if_t&lt; all_of&lt; std::is_copy_assignable&lt; Container &gt;, std::is_same&lt; typename Container::value_type &amp;, typename Container::reference &gt; &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__copy__assignable_3_01_container_00_01enable__if__t_3_01all__of_3_01std_1_1is__copy__as20354ef08d46a22473be8f5a1c6ade9a.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_copy_assignable&lt; std::pair&lt; T1, T2 &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_copy_assignable&lt; std::pair&lt; T1, T2 &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__copy__assignable_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_copy_constructible</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_copy_constructible</Scope>
    </TokenIdentifier>
    <Path>structis__copy__constructible.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_copy_constructible&lt; Container, enable_if_t&lt; all_of&lt; std::is_copy_constructible&lt; Container &gt;, std::is_same&lt; typename Container::value_type &amp;, typename Container::reference &gt;, negation&lt; std::is_same&lt; Container, typename Container::value_type &gt; &gt; &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_copy_constructible&lt; Container, enable_if_t&lt; all_of&lt; std::is_copy_constructible&lt; Container &gt;, std::is_same&lt; typename Container::value_type &amp;, typename Container::reference &gt;, negation&lt; std::is_same&lt; Container, typename Container::value_type &gt; &gt; &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__copy__constructible_3_01_container_00_01enable__if__t_3_01all__of_3_01std_1_1is__copy_71035f87d87bde541f2f835e06fd54cb.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_copy_constructible&lt; std::pair&lt; T1, T2 &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_copy_constructible&lt; std::pair&lt; T1, T2 &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__copy__constructible_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_final</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>is_final</Scope>
    </TokenIdentifier>
    <Path>structis__final.html</Path>
    <Abstract>Annotation for classes that cannot be subclassed.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_fmt_numeric</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_fmt_numeric</Scope>
    </TokenIdentifier>
    <Path>structis__fmt__numeric.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_fmt_numeric&lt; std::complex&lt; T &gt;, detail::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_fmt_numeric&lt; std::complex&lt; T &gt;, detail::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__fmt__numeric_3_01std_1_1complex_3_01_t_01_4_00_01detail_1_1enable__if__t_3_01std_1_1is996a96e2979aed124e8880b0fa5542e3.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_fmt_numeric&lt; T, enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_fmt_numeric&lt; T, enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__fmt__numeric_3_01_t_00_01enable__if__t_3_01std_1_1is__arithmetic_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_holder_type</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_holder_type</Scope>
    </TokenIdentifier>
    <Path>structis__holder__type.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_holder_type&lt; base, std::unique_ptr&lt; base, deleter &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_holder_type&lt; base, std::unique_ptr&lt; base, deleter &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__holder__type_3_01base_00_01std_1_1unique__ptr_3_01base_00_01deleter_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_input_iterator</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_input_iterator</Scope>
    </TokenIdentifier>
    <Path>structis__input__iterator.html</Path>
    <Abstract>Check if T looks like an input iterator.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_input_iterator&lt; T, void_t&lt; decltype(*std::declval&lt; T &amp; &gt;()), decltype(++std::declval&lt; T &amp; &gt;())&gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_input_iterator&lt; T, void_t&lt; decltype(*std::declval&lt; T &amp; &gt;()), decltype(++std::declval&lt; T &amp; &gt;())&gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__input__iterator_3_01_t_00_01void__t_3_01decltype_07_5std_1_1declval_3_01_t_01_6_01_4_07d75bfb9a8f56371f7d25507c315f9a0.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_instantiation</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_instantiation</Scope>
    </TokenIdentifier>
    <Path>structis__instantiation.html</Path>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_instantiation&lt; Class, Class&lt; Us... &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_instantiation&lt; Class, Class&lt; Us... &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__instantiation_3_01_class_00_01_class_3_01_us_8_8_8_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_method</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>is_method</Scope>
    </TokenIdentifier>
    <Path>structis__method.html</Path>
    <Abstract>Annotation for methods.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_new_style_constructor</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>is_new_style_constructor</Scope>
    </TokenIdentifier>
    <Path>structis__new__style__constructor.html</Path>
    <Abstract>Tag for a new-style __init__ defined in detail/init.h</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_operator</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>is_operator</Scope>
    </TokenIdentifier>
    <Path>structis__operator.html</Path>
    <Abstract>Annotation for operators.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_std_array</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_std_array</Scope>
    </TokenIdentifier>
    <Path>structis__std__array.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_std_array&lt; std::array&lt; T, N &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_std_array&lt; std::array&lt; T, N &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structis__std__array_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_template_base_of_impl</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>is_template_base_of_impl</Scope>
    </TokenIdentifier>
    <Path>structis__template__base__of__impl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>iterable</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>iterable</Scope>
    </TokenIdentifier>
    <Path>classiterable.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>iterator</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>iterator</Scope>
    </TokenIdentifier>
    <Path>classiterator.html</Path>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sentinel</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>iterator</Scope>
    </TokenIdentifier>
    <Path>classiterator.html</Path>
    <Anchor>ace2b4797f9e34e51c1df9d52ba164203</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>iterator_state</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>iterator_state</Scope>
    </TokenIdentifier>
    <Path>structiterator__state.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>keep_alive</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>keep_alive</Scope>
    </TokenIdentifier>
    <Path>structkeep__alive.html</Path>
    <Abstract>Keep patient alive while nurse lives.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>kwargs</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>kwargs</Scope>
    </TokenIdentifier>
    <Path>classkwargs.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>kwargs_proxy</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>kwargs_proxy</Scope>
    </TokenIdentifier>
    <Path>classkwargs__proxy.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>kwonly</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>kwonly</Scope>
    </TokenIdentifier>
    <Path>structkwonly.html</Path>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Labrador</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Labrador</Scope>
    </TokenIdentifier>
    <Path>struct_labrador.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>lacking_copy_ctor</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>lacking_copy_ctor</Scope>
    </TokenIdentifier>
    <Path>structlacking__copy__ctor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>lacking_move_ctor</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>lacking_move_ctor</Scope>
    </TokenIdentifier>
    <Path>structlacking__move__ctor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>list</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>list</Scope>
    </TokenIdentifier>
    <Path>classlist.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>list_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>list_caster</Scope>
    </TokenIdentifier>
    <Path>structlist__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>list_item</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>list_item</Scope>
    </TokenIdentifier>
    <Path>structlist__item.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>loader_life_support</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>loader_life_support</Scope>
    </TokenIdentifier>
    <Path>classloader__life__support.html</Path>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>loader_life_support</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>loader_life_support</Scope>
    </TokenIdentifier>
    <Path>classloader__life__support.html</Path>
    <Anchor>abd8830be409a78f3dfb6741b045ad929</Anchor>
    <Abstract>A new patient frame is created when a function is entered.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~loader_life_support</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>loader_life_support</Scope>
    </TokenIdentifier>
    <Path>classloader__life__support.html</Path>
    <Anchor>ae37f1ea05059dff6ef805d1dcd34b3e4</Anchor>
    <Abstract>... and destroyed after it returns</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>add_patient</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>loader_life_support</Scope>
    </TokenIdentifier>
    <Path>classloader__life__support.html</Path>
    <Anchor>a0759a5fe160fb836f1f1d47eecdfb36f</Anchor>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>LocalBase</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>LocalBase</Scope>
    </TokenIdentifier>
    <Path>class_local_base.html</Path>
    <Abstract>Simple class used to test py::local:</Abstract>
    <DeclaredIn>local_bindings.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>make_index_sequence_impl</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>make_index_sequence_impl</Scope>
    </TokenIdentifier>
    <Path>structmake__index__sequence__impl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>make_index_sequence_impl&lt; 0, S... &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>make_index_sequence_impl&lt; 0, S... &gt;</Scope>
    </TokenIdentifier>
    <Path>structmake__index__sequence__impl_3_010_00_01_s_8_8_8_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>map_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>map_caster</Scope>
    </TokenIdentifier>
    <Path>structmap__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>memoryview</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>memoryview</Scope>
    </TokenIdentifier>
    <Path>classmemoryview.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>metaclass</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>metaclass</Scope>
    </TokenIdentifier>
    <Path>structmetaclass.html</Path>
    <Abstract>Annotation which requests that a special metaclass is created for a type.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>metaclass</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>metaclass</Scope>
    </TokenIdentifier>
    <Path>structmetaclass.html</Path>
    <Anchor>a315277a15107c2eb0136076274cdcee9</Anchor>
    <Abstract>Override pybind11&apos;s default metaclass.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MixGL</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MixGL</Scope>
    </TokenIdentifier>
    <Path>struct_mix_g_l.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MixGL2</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MixGL2</Scope>
    </TokenIdentifier>
    <Path>struct_mix_g_l2.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>module</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>module</Scope>
    </TokenIdentifier>
    <Path>classmodule.html</Path>
    <Abstract>Wrapper for Python extension modules.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>module</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>module</Scope>
    </TokenIdentifier>
    <Path>classmodule.html</Path>
    <Anchor>abd798017921903073343c4479efb93c0</Anchor>
    <Abstract>Create a new top-level Python module with the given name and docstring.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>module</Scope>
    </TokenIdentifier>
    <Path>classmodule.html</Path>
    <Anchor>ab17b2e694f8a83305c1b707363a1ccdf</Anchor>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>def_submodule</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>module</Scope>
    </TokenIdentifier>
    <Path>classmodule.html</Path>
    <Anchor>a0e559dd7ef70d0edd90d0327ddbd0c12</Anchor>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>reload</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>module</Scope>
    </TokenIdentifier>
    <Path>classmodule.html</Path>
    <Anchor>a6ca13662c15143718888ae5cb13094b0</Anchor>
    <Abstract>Reload the module or throws error_already_set.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>import</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>module</Scope>
    </TokenIdentifier>
    <Path>classmodule.html</Path>
    <Anchor>a40817edef0ded5727701534bcded9982</Anchor>
    <Abstract>Import and return a module or throws error_already_set.</Abstract>
    <DeclaredIn>pybind11.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>module_local</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>module_local</Scope>
    </TokenIdentifier>
    <Path>structmodule__local.html</Path>
    <Abstract>Annotation that marks a class as local to the module:</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Movable</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Movable</Scope>
    </TokenIdentifier>
    <Path>class_movable.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>move_always</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>move_always</Scope>
    </TokenIdentifier>
    <Path>structmove__always.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>move_always&lt; T, enable_if_t&lt; all_of&lt; move_is_plain_type&lt; T &gt;, negation&lt; is_copy_constructible&lt; T &gt; &gt;, std::is_move_constructible&lt; T &gt;, std::is_same&lt; decltype(std::declval&lt; make_caster&lt; T &gt;&gt;().operator T&amp;()), T &amp; &gt;&gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>move_always&lt; T, enable_if_t&lt; all_of&lt; move_is_plain_type&lt; T &gt;, negation&lt; is_copy_constructible&lt; T &gt; &gt;, std::is_move_constructible&lt; T &gt;, std::is_same&lt; decltype(std::declval&lt; make_caster&lt; T &gt;&gt;().operator T&amp;()), T &amp; &gt;&gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structmove__always_3_01_t_00_01enable__if__t_3_01all__of_3_01move__is__plain__type_3_01_t_01_4_0f8272520c95117827c2a820ec07a607e.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>move_if_unreferenced</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>move_if_unreferenced</Scope>
    </TokenIdentifier>
    <Path>structmove__if__unreferenced.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>move_if_unreferenced&lt; T, enable_if_t&lt; all_of&lt; move_is_plain_type&lt; T &gt;, negation&lt; move_always&lt; T &gt; &gt;, std::is_move_constructible&lt; T &gt;, std::is_same&lt; decltype(std::declval&lt; make_caster&lt; T &gt;&gt;().operator T&amp;()), T &amp; &gt;&gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>move_if_unreferenced&lt; T, enable_if_t&lt; all_of&lt; move_is_plain_type&lt; T &gt;, negation&lt; move_always&lt; T &gt; &gt;, std::is_move_constructible&lt; T &gt;, std::is_same&lt; decltype(std::declval&lt; make_caster&lt; T &gt;&gt;().operator T&amp;()), T &amp; &gt;&gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structmove__if__unreferenced_3_01_t_00_01enable__if__t_3_01all__of_3_01move__is__plain__type_3_02ef9d875671610a54c664111bc370112.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>move_only_holder_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>move_only_holder_caster</Scope>
    </TokenIdentifier>
    <Path>structmove__only__holder__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MoveOnlyInt</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MoveOnlyInt</Scope>
    </TokenIdentifier>
    <Path>class_move_only_int.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MoveOrCopyInt</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MoveOrCopyInt</Scope>
    </TokenIdentifier>
    <Path>class_move_or_copy_int.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>multi_array_iterator</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>multi_array_iterator</Scope>
    </TokenIdentifier>
    <Path>classmulti__array__iterator.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>multiple_inheritance</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>multiple_inheritance</Scope>
    </TokenIdentifier>
    <Path>structmultiple__inheritance.html</Path>
    <Abstract>Annotation indicating that a class is involved in a multiple inheritance relationship.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MyException</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MyException</Scope>
    </TokenIdentifier>
    <Path>class_my_exception.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MyException2</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MyException2</Scope>
    </TokenIdentifier>
    <Path>class_my_exception2.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MyException3</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MyException3</Scope>
    </TokenIdentifier>
    <Path>class_my_exception3.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MyException4</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MyException4</Scope>
    </TokenIdentifier>
    <Path>class_my_exception4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MyException5</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MyException5</Scope>
    </TokenIdentifier>
    <Path>class_my_exception5.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>MyException5_1</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>MyException5_1</Scope>
    </TokenIdentifier>
    <Path>class_my_exception5__1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>name</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>name</Scope>
    </TokenIdentifier>
    <Path>structname.html</Path>
    <Abstract>Annotation for function names.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>NCVirt</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>NCVirt</Scope>
    </TokenIdentifier>
    <Path>class_n_c_virt.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>NCVirtTrampoline</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>NCVirtTrampoline</Scope>
    </TokenIdentifier>
    <Path>class_n_c_virt_trampoline.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>negation</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>negation</Scope>
    </TokenIdentifier>
    <Path>structnegation.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>NoBraceInitialization</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>NoBraceInitialization</Scope>
    </TokenIdentifier>
    <Path>struct_no_brace_initialization.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nodelete</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>nodelete</Scope>
    </TokenIdentifier>
    <Path>structnodelete.html</Path>
    <Abstract>Dummy destructor wrapper that can be used to expose classes with a private destructor.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>NonCopyable</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>NonCopyable</Scope>
    </TokenIdentifier>
    <Path>class_non_copyable.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>none</Scope>
    </TokenIdentifier>
    <Path>classnone.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>NoneTester</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>NoneTester</Scope>
    </TokenIdentifier>
    <Path>class_none_tester.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nonsimple_values_and_holders</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>nonsimple_values_and_holders</Scope>
    </TokenIdentifier>
    <Path>structnonsimple__values__and__holders.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>NonZeroIterator</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>NonZeroIterator</Scope>
    </TokenIdentifier>
    <Path>class_non_zero_iterator.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>NonZeroSentinel</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>NonZeroSentinel</Scope>
    </TokenIdentifier>
    <Path>class_non_zero_sentinel.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_api</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>npy_api</Scope>
    </TokenIdentifier>
    <Path>structnpy__api.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_api::PyArray_Dims</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>npy_api::PyArray_Dims</Scope>
    </TokenIdentifier>
    <Path>structnpy__api_1_1_py_array___dims.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor&lt; char[N]&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor&lt; char[N]&gt;</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor_3_01char_0f_n_0e_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor&lt; std::array&lt; char, N &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor&lt; std::array&lt; char, N &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor&lt; T, enable_if_t&lt; array_info&lt; T &gt;::is_array &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor&lt; T, enable_if_t&lt; array_info&lt; T &gt;::is_array &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor_3_01_t_00_01enable__if__t_3_01array__info_3_01_t_01_4_1_1is__array_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor&lt; T, enable_if_t&lt; satisfies_any_of&lt; T, std::is_arithmetic, is_complex &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor&lt; T, enable_if_t&lt; satisfies_any_of&lt; T, std::is_arithmetic, is_complex &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor_3_01_t_00_01enable__if__t_3_01satisfies__any__of_3_01_t_00_01std_19664305ecd151fe63e888175be34ab54.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor&lt; T, enable_if_t&lt; std::is_enum&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor&lt; T, enable_if_t&lt; std::is_enum&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor_3_01_t_00_01enable__if__t_3_01std_1_1is__enum_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor_name</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor_name</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor__name.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor_name&lt; T, enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor_name&lt; T, enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor__name_3_01_t_00_01enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor_name&lt; T, enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor_name&lt; T, enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor__name_3_01_t_00_01enable__if__t_3_01std_1_1is__floating__point_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>npy_format_descriptor_name&lt; T, enable_if_t&lt; std::is_integral&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>npy_format_descriptor_name&lt; T, enable_if_t&lt; std::is_integral&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structnpy__format__descriptor__name_3_01_t_00_01enable__if__t_3_01std_1_1is__integral_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>numpy_internals</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>numpy_internals</Scope>
    </TokenIdentifier>
    <Path>structnumpy__internals.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>numpy_type_info</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>numpy_type_info</Scope>
    </TokenIdentifier>
    <Path>structnumpy__type__info.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>obj_attr</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>obj_attr</Scope>
    </TokenIdentifier>
    <Path>structobj__attr.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>reinterpret_borrow</Name>
      <APILanguage>cpp</APILanguage>
      <Type>ffunc</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>ac1ea1a4cbcf197d7c8096037633720d7</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>reinterpret_steal</Name>
      <APILanguage>cpp</APILanguage>
      <Type>ffunc</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>ae1de2ab5a755c10582ac1e46071de5c5</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object::borrowed_t</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>object::borrowed_t</Scope>
    </TokenIdentifier>
    <Path>structobject_1_1borrowed__t.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object::stolen_t</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>object::stolen_t</Scope>
    </TokenIdentifier>
    <Path>structobject_1_1stolen__t.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Object</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Object</Scope>
    </TokenIdentifier>
    <Path>class_object.html</Path>
    <Abstract>Reference counted object base class.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>Object</Scope>
    </TokenIdentifier>
    <Path>class_object.html</Path>
    <Anchor>a40860402e64d8008fb42329df7097cdb</Anchor>
    <Abstract>Default constructor.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>Object</Scope>
    </TokenIdentifier>
    <Path>class_object.html</Path>
    <Anchor>af3b5cd7a9a24ddde484344200cf83281</Anchor>
    <Abstract>Copy constructor.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>getRefCount</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>Object</Scope>
    </TokenIdentifier>
    <Path>class_object.html</Path>
    <Anchor>a4f97f143f9fb46ac52e2f11cfa034005</Anchor>
    <Abstract>Return the current reference count.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>incRef</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>Object</Scope>
    </TokenIdentifier>
    <Path>class_object.html</Path>
    <Anchor>a769b55a36d5a2d42af6ef37be0789f43</Anchor>
    <Abstract>Increase the object&apos;s reference count by one.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>decRef</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>Object</Scope>
    </TokenIdentifier>
    <Path>class_object.html</Path>
    <Anchor>aee1171037ab2f9137ff9864ceb8f3086</Anchor>
    <Abstract>Decrease the reference count of the object and possibly deallocate it.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~Object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>Object</Scope>
    </TokenIdentifier>
    <Path>class_object.html</Path>
    <Anchor>aa3e791419d84c4c346ef9499513b8e00</Anchor>
    <Abstract>Virtual protected deconstructor. (Will only be called by ref)</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object_api</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>begin</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a18ff315942ef1238c6c9d28c0ef9301f</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>end</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a67b1b3d151adc273eeda39837e63f581</Anchor>
    <Abstract>Return a sentinel which ends iteration.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator[]</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a22a02d920a489c385a2502802e547943</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator[]</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a81277a47b87a2a79f216895d7a5018a8</Anchor>
    <Abstract>See above (the only difference is that they key is provided as a string literal)</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>attr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a17b39579263007abe74cfbf80015ebd9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>attr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>ae5a18d371ec699cd68561d78503b493f</Anchor>
    <Abstract>See above (the only difference is that they key is provided as a string literal)</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator*</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a52879030de31db181cb1ec02c6f001b4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>contains</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a07869da2a7cdbcb1a8877c50b18aee83</Anchor>
    <Abstract>Check if the given item is contained within this object, i.e. item in obj.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator()</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>abe9df612ead8f4239dc32154d68e0cc1</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a63b93f9f16e8e08c9672fe553c054885</Anchor>
    <Abstract>Equivalent to obj is other in Python.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a29bb566d25e37a236a322267ef1c59eb</Anchor>
    <Abstract>Equivalent to obj is None in Python.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>equal</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>ae1d3648ad3568f13a4e9f28556bb6e99</Anchor>
    <Abstract>Equivalent to obj == other in Python.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>doc</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>ad1febfb66cd1ecdc3d339ad0125f6da8</Anchor>
    <Abstract>Get or set the object&apos;s docstring, i.e. obj.__doc__.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ref_count</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>ad342c9c181e1c9bdd634828276aebd24</Anchor>
    <Abstract>Return the object&apos;s current reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get_type</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object_api</Scope>
    </TokenIdentifier>
    <Path>classobject__api.html</Path>
    <Anchor>a6e7d5542b300b4ef13c65c58124a410a</Anchor>
    <Abstract>Return a handle to the Python type object underlying the instance.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>op_</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>op_</Scope>
    </TokenIdentifier>
    <Path>structop__.html</Path>
    <Abstract>Operator implementation generator.</Abstract>
    <DeclaredIn>operators.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>op_impl</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>op_impl</Scope>
    </TokenIdentifier>
    <Path>structop__impl.html</Path>
    <Abstract>base template of operator implementations</Abstract>
    <DeclaredIn>operators.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>optional_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>optional_caster</Scope>
    </TokenIdentifier>
    <Path>structoptional__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>options</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>options</Scope>
    </TokenIdentifier>
    <Path>classoptions.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>options::state</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>options::state</Scope>
    </TokenIdentifier>
    <Path>structoptions_1_1state.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>OstreamRedirect</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>OstreamRedirect</Scope>
    </TokenIdentifier>
    <Path>class_ostream_redirect.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>overload_cast</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>overload_cast</Scope>
    </TokenIdentifier>
    <Path>structoverload__cast.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>overload_cast_impl</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>overload_cast_impl</Scope>
    </TokenIdentifier>
    <Path>structoverload__cast__impl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>overload_hash</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>overload_hash</Scope>
    </TokenIdentifier>
    <Path>structoverload__hash.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>overload_unused</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>overload_unused</Scope>
    </TokenIdentifier>
    <Path>structoverload__unused.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pack_element</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>pack_element</Scope>
    </TokenIdentifier>
    <Path>structpack__element.html</Path>
    <Abstract>Return the Nth element from the parameter pack.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pack_element&lt; 0, T, Ts... &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>pack_element&lt; 0, T, Ts... &gt;</Scope>
    </TokenIdentifier>
    <Path>structpack__element_3_010_00_01_t_00_01_ts_8_8_8_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Panther</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Panther</Scope>
    </TokenIdentifier>
    <Path>struct_panther.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PartialNestedStruct</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PartialNestedStruct</Scope>
    </TokenIdentifier>
    <Path>struct_partial_nested_struct.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PartialStruct</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PartialStruct</Scope>
    </TokenIdentifier>
    <Path>struct_partial_struct.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pickle_factory</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>pickle_factory</Scope>
    </TokenIdentifier>
    <Path>structpickle__factory.html</Path>
    <Abstract>Implementation for py::pickle(GetState, SetState)</Abstract>
    <DeclaredIn>init.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pickle_factory&lt; Get, Set, RetState(Self), NewInstance(ArgState)&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>pickle_factory&lt; Get, Set, RetState(Self), NewInstance(ArgState)&gt;</Scope>
    </TokenIdentifier>
    <Path>structpickle__factory_3_01_get_00_01_set_00_01_ret_state_07_self_08_00_01_new_instance_07_arg_state_08_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>polymorphic_type_hook</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>polymorphic_type_hook</Scope>
    </TokenIdentifier>
    <Path>structpolymorphic__type__hook.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>polymorphic_type_hook_base</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>polymorphic_type_hook_base</Scope>
    </TokenIdentifier>
    <Path>structpolymorphic__type__hook__base.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>polymorphic_type_hook_base&lt; itype, detail::enable_if_t&lt; std::is_polymorphic&lt; itype &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>polymorphic_type_hook_base&lt; itype, detail::enable_if_t&lt; std::is_polymorphic&lt; itype &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structpolymorphic__type__hook__base_3_01itype_00_01detail_1_1enable__if__t_3_01std_1_1is__polymo8c44a93e5e895035606b5f8ce634aa3b.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>process_attribute</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute.html</Path>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; arg &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; arg &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01arg_01_4.html</Path>
    <Abstract>Process a keyword argument attribute (without a default value)</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; arg &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; arg_v &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; arg_v &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01arg__v_01_4.html</Path>
    <Abstract>Process a keyword argument attribute (with a default value)</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; arg_v &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; arithmetic &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; arithmetic &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01arithmetic_01_4.html</Path>
    <Abstract>Process an &apos;arithmetic&apos; attribute for enums (does nothing here)</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; arithmetic &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; base&lt; T &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>process_attribute&lt; base&lt; T &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01base_3_01_t_01_4_01_4.html</Path>
    <Abstract>Process a parent class attribute (deprecated, does not support multiple inheritance)</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; base&lt; T &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; buffer_protocol &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; buffer_protocol &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01buffer__protocol_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; buffer_protocol &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; call_guard&lt; Ts... &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>process_attribute&lt; call_guard&lt; Ts... &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01call__guard_3_01_ts_8_8_8_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; call_guard&lt; Ts... &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; char * &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; char * &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01char_01_5_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; const char * &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; const char * &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; const char * &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01const_01char_01_5_01_4.html</Path>
    <Abstract>Process an attribute specifying the function&apos;s docstring (provided as a C-style string)</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; const char * &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; doc &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; doc &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01doc_01_4.html</Path>
    <Abstract>Process an attribute specifying the function&apos;s docstring.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; doc &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; dynamic_attr &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; dynamic_attr &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01dynamic__attr_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; dynamic_attr &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; is_final &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; is_final &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01is__final_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; is_final &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; is_method &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; is_method &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01is__method_01_4.html</Path>
    <Abstract>Process an attribute which indicates that this function is a method.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; is_method &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; is_new_style_constructor &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; is_new_style_constructor &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01is__new__style__constructor_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; is_new_style_constructor &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; is_operator &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; is_operator &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01is__operator_01_4.html</Path>
    <Abstract>Process an attribute which indicates that this function is an operator.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; is_operator &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; keep_alive&lt; Nurse, Patient &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>process_attribute&lt; keep_alive&lt; Nurse, Patient &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01keep__alive_3_01_nurse_00_01_patient_01_4_01_4.html</Path>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; keep_alive&lt; Nurse, Patient &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; kwonly &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; kwonly &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01kwonly_01_4.html</Path>
    <Abstract>Process a keyword-only-arguments-follow pseudo argument.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; kwonly &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; metaclass &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; metaclass &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01metaclass_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; metaclass &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; module_local &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; module_local &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01module__local_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; module_local &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; multiple_inheritance &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; multiple_inheritance &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01multiple__inheritance_01_4.html</Path>
    <Abstract>Process a multiple inheritance attribute.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; multiple_inheritance &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; name &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; name &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01name_01_4.html</Path>
    <Abstract>Process an attribute specifying the function&apos;s name.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; name &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; return_value_policy &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; return_value_policy &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01return__value__policy_01_4.html</Path>
    <Abstract>Process an attribute indicating the function&apos;s return value policy.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; return_value_policy &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; scope &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; scope &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01scope_01_4.html</Path>
    <Abstract>Process an attribute which indicates the parent scope of a method.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; scope &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; sibling &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>process_attribute&lt; sibling &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01sibling_01_4.html</Path>
    <Abstract>Process an attribute which indicates that this is an overloaded function associated with a given sibl...</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; sibling &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute&lt; T, enable_if_t&lt; is_pyobject&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>process_attribute&lt; T, enable_if_t&lt; is_pyobject&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute_3_01_t_00_01enable__if__t_3_01is__pyobject_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
    <Abstract>Process a parent class attribute. Single inheritance only (class_ itself already guarantees that)</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>unknown</APILanguage>
      <Type>clm</Type>
      <Scope>process_attribute_default&lt; handle &gt;</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attribute_default</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>process_attribute_default</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>process_attribute_default</Scope>
    </TokenIdentifier>
    <Path>structprocess__attribute__default.html</Path>
    <Anchor>a5c9bf3410349e942871e45c5c0097a23</Anchor>
    <Abstract>Default implementation: do nothing.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>process_attributes</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>process_attributes</Scope>
    </TokenIdentifier>
    <Path>structprocess__attributes.html</Path>
    <Abstract>Recursively iterate over variadic template arguments.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyA_Repeat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyA_Repeat</Scope>
    </TokenIdentifier>
    <Path>class_py_a___repeat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyA_Tpl</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>PyA_Tpl</Scope>
    </TokenIdentifier>
    <Path>class_py_a___tpl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyArray_Proxy</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyArray_Proxy</Scope>
    </TokenIdentifier>
    <Path>struct_py_array___proxy.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyArrayDescr_Proxy</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyArrayDescr_Proxy</Scope>
    </TokenIdentifier>
    <Path>struct_py_array_descr___proxy.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyB_Repeat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyB_Repeat</Scope>
    </TokenIdentifier>
    <Path>class_py_b___repeat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyB_Tpl</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>PyB_Tpl</Scope>
    </TokenIdentifier>
    <Path>class_py_b___tpl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyC_Repeat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyC_Repeat</Scope>
    </TokenIdentifier>
    <Path>class_py_c___repeat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyD_Repeat</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyD_Repeat</Scope>
    </TokenIdentifier>
    <Path>class_py_d___repeat.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyExampleVirt</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyExampleVirt</Scope>
    </TokenIdentifier>
    <Path>class_py_example_virt.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pyobject_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>pyobject_caster</Scope>
    </TokenIdentifier>
    <Path>structpyobject__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pyobject_caster&lt; array_t&lt; T, ExtraFlags &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>pyobject_caster&lt; array_t&lt; T, ExtraFlags &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structpyobject__caster_3_01array__t_3_01_t_00_01_extra_flags_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pyobject_tag</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>pyobject_tag</Scope>
    </TokenIdentifier>
    <Path>classpyobject__tag.html</Path>
    <Abstract>Tag and check to identify a class which implements the Python object API.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyTF6</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyTF6</Scope>
    </TokenIdentifier>
    <Path>class_py_t_f6.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyTF7</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyTF7</Scope>
    </TokenIdentifier>
    <Path>class_py_t_f7.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pythonbuf</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>pythonbuf</Scope>
    </TokenIdentifier>
    <Path>classpythonbuf.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~pythonbuf</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>pythonbuf</Scope>
    </TokenIdentifier>
    <Path>classpythonbuf.html</Path>
    <Anchor>a3f1ff4b8d6c45c702a64251a0212a79c</Anchor>
    <Abstract>Sync before destroy.</Abstract>
    <DeclaredIn>iostream.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PythonCallInDestructor</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PythonCallInDestructor</Scope>
    </TokenIdentifier>
    <Path>struct_python_call_in_destructor.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyVirtClass</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyVirtClass</Scope>
    </TokenIdentifier>
    <Path>class_py_virt_class.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyVoidScalarObject_Proxy</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyVoidScalarObject_Proxy</Scope>
    </TokenIdentifier>
    <Path>struct_py_void_scalar_object___proxy.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>PyWidget</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>PyWidget</Scope>
    </TokenIdentifier>
    <Path>class_py_widget.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ref</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Abstract>Reference counting helper.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a32c2f3c2bde5b57e6ef0a80254773854</Anchor>
    <Abstract>Create a nullptr reference.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>ac593e903c13a8dfe520978053ac4b319</Anchor>
    <Abstract>Construct a reference from a pointer.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>ab6041fce6b4a78faac0613b3b05e74e0</Anchor>
    <Abstract>Copy constructor.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>aad576503d5b820e6d1bbf33d881dc7a7</Anchor>
    <Abstract>Move constructor.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a0f91cf031c803c7a34471dabce694454</Anchor>
    <Abstract>Destroy this reference.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator=</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>aed9cb8611b7e85e2a3ee5d05b13b9a0b</Anchor>
    <Abstract>Move another reference into the current one.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator=</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a1155f824011414922d9b6a3b5d90c8d8</Anchor>
    <Abstract>Overwrite this reference with another reference.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator=</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a16ebd4ab3890e76d47cf7ef30f338690</Anchor>
    <Abstract>Overwrite this reference with a pointer to another object.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a8a96aae6d9787e988ff148d1dd9a773d</Anchor>
    <Abstract>Compare this reference with another reference.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator!=</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>ae4fb583b5cdbd8659c8dfc91ca5ba4f2</Anchor>
    <Abstract>Compare this reference with another reference.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a6131b1c40dd6977c7e005826ba660213</Anchor>
    <Abstract>Compare this reference with a pointer.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator!=</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a932a54e9c0e107e7edf78d550ef4852f</Anchor>
    <Abstract>Compare this reference with a pointer.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator-&gt;</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>acc07281f5c8afd7660e0965da19a2c0c</Anchor>
    <Abstract>Access the object referenced by this reference.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator-&gt;</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a2b60a27dafb793f808195c2ddfd8d013</Anchor>
    <Abstract>Access the object referenced by this reference.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator*</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a04924b0547cd850f3a39fda293021e3b</Anchor>
    <Abstract>Return a C++ reference to the referenced object.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator*</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a42119083ef6adbb393680aaee8331f25</Anchor>
    <Abstract>Return a const C++ reference to the referenced object.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator T*</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a6afd60eceb2144f888591fe9b3a05b86</Anchor>
    <Abstract>Return a pointer to the referenced object.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get_ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>ad70261d8ee00b42350f69c96be30beaa</Anchor>
    <Abstract>Return a const pointer to the referenced object.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get_ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>ref</Scope>
    </TokenIdentifier>
    <Path>classref.html</Path>
    <Anchor>a76b8f2eec00eb3c3041cc9c7fb14ba0b</Anchor>
    <Abstract>Return a pointer to the referenced object.</Abstract>
    <DeclaredIn>object.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ref_tag</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>ref_tag</Scope>
    </TokenIdentifier>
    <Path>classref__tag.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>RefQualified</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>RefQualified</Scope>
    </TokenIdentifier>
    <Path>struct_ref_qualified.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>RegisteredDerived</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>RegisteredDerived</Scope>
    </TokenIdentifier>
    <Path>class_registered_derived.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>remove_class</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>remove_class</Scope>
    </TokenIdentifier>
    <Path>structremove__class.html</Path>
    <Abstract>Strip the class from a method type.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>remove_class&lt; R(C::*)(A...) const &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>remove_class&lt; R(C::*)(A...) const &gt;</Scope>
    </TokenIdentifier>
    <Path>structremove__class_3_01_r_07_c_1_1_5_08_07_a_8_8_8_08_01const_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>remove_class&lt; R(C::*)(A...)&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>remove_class&lt; R(C::*)(A...)&gt;</Scope>
    </TokenIdentifier>
    <Path>structremove__class_3_01_r_07_c_1_1_5_08_07_a_8_8_8_08_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>return_value_policy_override</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>return_value_policy_override</Scope>
    </TokenIdentifier>
    <Path>structreturn__value__policy__override.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>return_value_policy_override&lt; Return, detail::enable_if_t&lt; std::is_base_of&lt; type_caster_generic, make_caster&lt; Return &gt; &gt;::value, void &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>return_value_policy_override&lt; Return, detail::enable_if_t&lt; std::is_base_of&lt; type_caster_generic, make_caster&lt; Return &gt; &gt;::value, void &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structreturn__value__policy__override_3_01_return_00_01detail_1_1enable__if__t_3_01std_1_1is__badbc5555ea30d1cff9fa4aef329884809.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>RValueCaster</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>RValueCaster</Scope>
    </TokenIdentifier>
    <Path>struct_r_value_caster.html</Path>
    <DeclaredIn>pybind11_tests.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>same_size</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>same_size</Scope>
    </TokenIdentifier>
    <Path>structsame__size.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scope</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>scope</Scope>
    </TokenIdentifier>
    <Path>structscope.html</Path>
    <Abstract>Annotation for parent scope.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scope_exit</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>scope_exit</Scope>
    </TokenIdentifier>
    <Path>structscope__exit.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scoped_estream_redirect</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>scoped_estream_redirect</Scope>
    </TokenIdentifier>
    <Path>classscoped__estream__redirect.html</Path>
    <DeclaredIn>iostream.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scoped_interpreter</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>scoped_interpreter</Scope>
    </TokenIdentifier>
    <Path>classscoped__interpreter.html</Path>
    <DeclaredIn>embed.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scoped_ostream_redirect</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>scoped_ostream_redirect</Scope>
    </TokenIdentifier>
    <Path>classscoped__ostream__redirect.html</Path>
    <DeclaredIn>iostream.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>select_indices_impl</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>select_indices_impl</Scope>
    </TokenIdentifier>
    <Path>structselect__indices__impl.html</Path>
    <Abstract>Make an index sequence of the indices of true arguments.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>select_indices_impl&lt; index_sequence&lt; IPrev... &gt;, I, B, Bs... &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>select_indices_impl&lt; index_sequence&lt; IPrev... &gt;, I, B, Bs... &gt;</Scope>
    </TokenIdentifier>
    <Path>structselect__indices__impl_3_01index__sequence_3_01_i_prev_8_8_8_01_4_00_01_i_00_01_b_00_01_bs_8_8_8_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>self_t</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>self_t</Scope>
    </TokenIdentifier>
    <Path>structself__t.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sequence</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>sequence</Scope>
    </TokenIdentifier>
    <Path>classsequence.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sequence_fast_readonly</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>sequence_fast_readonly</Scope>
    </TokenIdentifier>
    <Path>classsequence__fast__readonly.html</Path>
    <Abstract>Lightweight iterator policy using just a simple pointer: see PySequence_Fast_ITEMS</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sequence_item</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>sequence_item</Scope>
    </TokenIdentifier>
    <Path>structsequence__item.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sequence_slow_readwrite</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>sequence_slow_readwrite</Scope>
    </TokenIdentifier>
    <Path>classsequence__slow__readwrite.html</Path>
    <Abstract>Full read and write access using the sequence protocol: see detail::sequence_accessor</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>set</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>set</Scope>
    </TokenIdentifier>
    <Path>classset.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>set_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>set_caster</Scope>
    </TokenIdentifier>
    <Path>structset__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>shared_ptr_with_addressof_operator</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>shared_ptr_with_addressof_operator</Scope>
    </TokenIdentifier>
    <Path>classshared__ptr__with__addressof__operator.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sibling</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>sibling</Scope>
    </TokenIdentifier>
    <Path>structsibling.html</Path>
    <Abstract>Annotation indicating that a function is an overload associated with a given &quot;sibling&quot;.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>simple_collector</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>simple_collector</Scope>
    </TokenIdentifier>
    <Path>classsimple__collector.html</Path>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>call</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>simple_collector</Scope>
    </TokenIdentifier>
    <Path>classsimple__collector.html</Path>
    <Anchor>aa5e692afd78c541e35034ff013d5ad1e</Anchor>
    <Abstract>Call a Python function and pass the collected arguments.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>SimpleStruct</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>SimpleStruct</Scope>
    </TokenIdentifier>
    <Path>struct_simple_struct.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>SimpleStructReordered</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>SimpleStructReordered</Scope>
    </TokenIdentifier>
    <Path>struct_simple_struct_reordered.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>slice</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>slice</Scope>
    </TokenIdentifier>
    <Path>classslice.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>staticmethod</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>staticmethod</Scope>
    </TokenIdentifier>
    <Path>classstaticmethod.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>str</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>str</Scope>
    </TokenIdentifier>
    <Path>classstr.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>str</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>str</Scope>
    </TokenIdentifier>
    <Path>classstr.html</Path>
    <Anchor>a4bff3c112fa3379ba8a668ca1547b85a</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>raw_str</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>str</Scope>
    </TokenIdentifier>
    <Path>classstr.html</Path>
    <Anchor>a0485ba623422e1c9d55da897ac35941a</Anchor>
    <Abstract>Return string representation â€“ always returns a new reference, even if already a str.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>str_attr</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>str_attr</Scope>
    </TokenIdentifier>
    <Path>structstr__attr.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>string_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>string_caster</Scope>
    </TokenIdentifier>
    <Path>structstring__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>StringStruct</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>StringStruct</Scope>
    </TokenIdentifier>
    <Path>struct_string_struct.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>strip_function_object</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>strip_function_object</Scope>
    </TokenIdentifier>
    <Path>structstrip__function__object.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>StrIssue</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>StrIssue</Scope>
    </TokenIdentifier>
    <Path>struct_str_issue.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>test_initializer</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>test_initializer</Scope>
    </TokenIdentifier>
    <Path>classtest__initializer.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestFactory1</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestFactory1</Scope>
    </TokenIdentifier>
    <Path>class_test_factory1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestFactory2</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestFactory2</Scope>
    </TokenIdentifier>
    <Path>class_test_factory2.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestFactory3</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestFactory3</Scope>
    </TokenIdentifier>
    <Path>class_test_factory3.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestFactory4</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestFactory4</Scope>
    </TokenIdentifier>
    <Path>class_test_factory4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestFactory5</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestFactory5</Scope>
    </TokenIdentifier>
    <Path>class_test_factory5.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestFactory6</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestFactory6</Scope>
    </TokenIdentifier>
    <Path>class_test_factory6.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestFactory7</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestFactory7</Scope>
    </TokenIdentifier>
    <Path>class_test_factory7.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestFactoryHelper</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestFactoryHelper</Scope>
    </TokenIdentifier>
    <Path>class_test_factory_helper.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestProperties</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestProperties</Scope>
    </TokenIdentifier>
    <Path>struct_test_properties.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestPropertiesOverride</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestPropertiesOverride</Scope>
    </TokenIdentifier>
    <Path>struct_test_properties_override.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TestPropRVP</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TestPropRVP</Scope>
    </TokenIdentifier>
    <Path>struct_test_prop_r_v_p.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>TplCtorClass</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>TplCtorClass</Scope>
    </TokenIdentifier>
    <Path>struct_tpl_ctor_class.html</Path>
    <Abstract>Issue #528: templated constructor.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>tuple</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>tuple</Scope>
    </TokenIdentifier>
    <Path>classtuple.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>tuple_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>tuple_caster</Scope>
    </TokenIdentifier>
    <Path>classtuple__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>tuple_item</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>tuple_item</Scope>
    </TokenIdentifier>
    <Path>structtuple__item.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster</Scope>
    </TokenIdentifier>
    <Path>classtype__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>try_load_foreign_module_local</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>type_caster_generic</Scope>
    </TokenIdentifier>
    <Path>classtype__caster__generic.html</Path>
    <Anchor>a9e76e336b90a56185b35d47c34aeecd7</Anchor>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; bool &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; bool &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01bool_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; CharT, enable_if_t&lt; is_std_char_type&lt; CharT &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; CharT, enable_if_t&lt; is_std_char_type&lt; CharT &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_char_t_00_01enable__if__t_3_01is__std__char__type_3_01_char_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; CopyOnlyInt &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; CopyOnlyInt &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_copy_only_int_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; MoveOnlyInt &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; MoveOnlyInt &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_move_only_int_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; MoveOrCopyInt &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; MoveOrCopyInt &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_move_or_copy_int_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; RValueCaster &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; RValueCaster &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01_r_value_caster_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::array&lt; Type, Size &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::array&lt; Type, Size &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1array_3_01_type_00_01_size_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::basic_string&lt; CharT, Traits, Allocator &gt;, enable_if_t&lt; is_std_char_type&lt; CharT &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::basic_string&lt; CharT, Traits, Allocator &gt;, enable_if_t&lt; is_std_char_type&lt; CharT &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1basic__string_3_01_char_t_00_01_traits_00_01_allocator_01_4_00_01ece498b5200b790571970efc6b6c56da1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::chrono::duration&lt; Rep, Period &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::chrono::duration&lt; Rep, Period &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1chrono_1_1duration_3_01_rep_00_01_period_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::chrono::time_point&lt; Clock, Duration &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::chrono::time_point&lt; Clock, Duration &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1chrono_1_1time__point_3_01_clock_00_01_duration_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::chrono::time_point&lt; std::chrono::system_clock, Duration &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::chrono::time_point&lt; std::chrono::system_clock, Duration &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1chrono_1_1time__point_3_01std_1_1chrono_1_1system__clock_00_01_duration_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::complex&lt; T &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::complex&lt; T &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1complex_3_01_t_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::deque&lt; Type, Alloc &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::deque&lt; Type, Alloc &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1deque_3_01_type_00_01_alloc_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::function&lt; Return(Args...)&gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::function&lt; Return(Args...)&gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1function_3_01_return_07_args_8_8_8_08_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::list&lt; Type, Alloc &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::list&lt; Type, Alloc &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1list_3_01_type_00_01_alloc_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::map&lt; Key, Value, Compare, Alloc &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::map&lt; Key, Value, Compare, Alloc &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1map_3_01_key_00_01_value_00_01_compare_00_01_alloc_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::nullptr_t &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; std::nullptr_t &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1nullptr__t_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::pair&lt; T1, T2 &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::pair&lt; T1, T2 &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::reference_wrapper&lt; type &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::reference_wrapper&lt; type &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1reference__wrapper_3_01type_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::set&lt; Key, Compare, Alloc &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::set&lt; Key, Compare, Alloc &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1set_3_01_key_00_01_compare_00_01_alloc_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::shared_ptr&lt; T &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::shared_ptr&lt; T &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1shared__ptr_3_01_t_01_4_01_4.html</Path>
    <Abstract>Specialize for the common std::shared_ptr, so users don&apos;t need to.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>try_load_foreign_module_local</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>type_caster_generic</Scope>
    </TokenIdentifier>
    <Path>classtype__caster__generic.html</Path>
    <Anchor>a9e76e336b90a56185b35d47c34aeecd7</Anchor>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::tuple&lt; Ts... &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::tuple&lt; Ts... &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::unique_ptr&lt; type, deleter &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::unique_ptr&lt; type, deleter &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01std_1_1unique__ptr_3_01type_00_01deleter_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::unordered_map&lt; Key, Value, Hash, Equal, Alloc &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::unordered_map&lt; Key, Value, Hash, Equal, Alloc &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1unordered__map_3_01_key_00_01_value_00_01_hash_00_01_equal_00_01_alloc_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::unordered_set&lt; Key, Hash, Equal, Alloc &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::unordered_set&lt; Key, Hash, Equal, Alloc &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1unordered__set_3_01_key_00_01_hash_00_01_equal_00_01_alloc_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::valarray&lt; Type &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::valarray&lt; Type &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1valarray_3_01_type_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; std::vector&lt; Type, Alloc &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; std::vector&lt; Type, Alloc &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01std_1_1vector_3_01_type_00_01_alloc_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; T, enable_if_t&lt; is_pyobject&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; T, enable_if_t&lt; is_pyobject&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01_t_00_01enable__if__t_3_01is__pyobject_3_01_t_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; T, enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;!is_std_char_type&lt; T &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; T, enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;!is_std_char_type&lt; T &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_t_00_01enable__if__t_3_01std_1_1is__arithmetic_3_01_t_01_4_1_1value_01_624f9972c532456d927e4470192416960.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; Type, enable_if_t&lt; is_eigen_dense_map&lt; Type &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; Type, enable_if_t&lt; is_eigen_dense_map&lt; Type &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_type_00_01enable__if__t_3_01is__eigen__dense__map_3_01_type_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; Type, enable_if_t&lt; is_eigen_dense_plain&lt; Type &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; Type, enable_if_t&lt; is_eigen_dense_plain&lt; Type &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_type_00_01enable__if__t_3_01is__eigen__dense__plain_3_01_type_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; Type, enable_if_t&lt; is_eigen_other&lt; Type &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; Type, enable_if_t&lt; is_eigen_other&lt; Type &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_type_00_01enable__if__t_3_01is__eigen__other_3_01_type_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; Type, enable_if_t&lt; is_eigen_sparse&lt; Type &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; Type, enable_if_t&lt; is_eigen_sparse&lt; Type &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_type_00_01enable__if__t_3_01is__eigen__sparse_3_01_type_01_4_1_1value_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; unchecked_mutable_reference&lt; T, Dim &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; unchecked_mutable_reference&lt; T, Dim &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01unchecked__mutable__reference_3_01_t_00_01_dim_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; unchecked_reference&lt; T, Dim &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster&lt; unchecked_reference&lt; T, Dim &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01unchecked__reference_3_01_t_00_01_dim_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; value_and_holder &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; value_and_holder &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01value__and__holder_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; void &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; void &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01void_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; void_type &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster&lt; void_type &gt;</Scope>
    </TokenIdentifier>
    <Path>classtype__caster_3_01void__type_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster_base</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_caster_base</Scope>
    </TokenIdentifier>
    <Path>classtype__caster__base.html</Path>
    <Abstract>Generic type caster for objects stored on the heap.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>try_load_foreign_module_local</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>type_caster_generic</Scope>
    </TokenIdentifier>
    <Path>classtype__caster__generic.html</Path>
    <Anchor>a9e76e336b90a56185b35d47c34aeecd7</Anchor>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster_generic</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_caster_generic</Scope>
    </TokenIdentifier>
    <Path>classtype__caster__generic.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>try_load_foreign_module_local</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>type_caster_generic</Scope>
    </TokenIdentifier>
    <Path>classtype__caster__generic.html</Path>
    <Anchor>a9e76e336b90a56185b35d47c34aeecd7</Anchor>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_equal_to</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_equal_to</Scope>
    </TokenIdentifier>
    <Path>structtype__equal__to.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_hash</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_hash</Scope>
    </TokenIdentifier>
    <Path>structtype__hash.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_info</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_info</Scope>
    </TokenIdentifier>
    <Path>structtype__info.html</Path>
    <DeclaredIn>internals.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_list</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>type_list</Scope>
    </TokenIdentifier>
    <Path>structtype__list.html</Path>
    <Abstract>Helper template which holds a list of types.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_record</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Abstract>Special data structure which (temporarily) holds metadata about a bound class.</Abstract>
    <DeclaredIn>attr.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>scope</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>ab188820ddf461b3b49818f34885c5687</Anchor>
    <Abstract>Handle to the parent scope.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>name</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>aaf93cf029bb1a9686fd5e72c16ea81a8</Anchor>
    <Abstract>Name of the class.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_size</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>aa49cb21026b070945a61a29f081a2442</Anchor>
    <Abstract>How large is the underlying C++ type?</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_align</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>acfe9a04defba752df8501040167c4382</Anchor>
    <Abstract>What is the alignment of the underlying C++ type?</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>holder_size</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>a5d94102cfaacdfcf2de248e00fe1afcd</Anchor>
    <Abstract>How large is the type&apos;s holder?</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator_new</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>a9c77a43dea54c475eada38b5ded56a2e</Anchor>
    <Abstract>The global operator new can be overridden with a class-specific variant.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>init_instance</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>ad1d597c02ba9ac676f2c98c96c3ccc54</Anchor>
    <Abstract>Function pointer to class_&lt;..&gt;::init_instance.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dealloc</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>ab2b5fe93f5c5d047014164e931c53c41</Anchor>
    <Abstract>Function pointer to class_&lt;..&gt;::dealloc.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>bases</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>ae84dc75887eb2af0bd2b3d1bcfe5496c</Anchor>
    <Abstract>List of base classes of the newly created type.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>doc</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>ab343e48279172cd6f8ed5a25036bd02b</Anchor>
    <Abstract>Optional docstring.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>metaclass</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>a07699840bb125ef8d7d17122975c4d17</Anchor>
    <Abstract>Custom metaclass (optional)</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>multiple_inheritance</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>a13c1d8df682426b1de648c1231979231</Anchor>
    <Abstract>Multiple inheritance marker.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dynamic_attr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>af7b44bfceaec849cd9832043600b247b</Anchor>
    <Abstract>Does the class manage a dict?</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>buffer_protocol</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>ab5910eea61616c06a02acc36efc21a57</Anchor>
    <Abstract>Does the class implement the buffer protocol?</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>default_holder</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>a22be67a2d89db4dcf7ea338dc435f5e3</Anchor>
    <Abstract>Is the default (unique_ptr) holder type used?</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>module_local</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>a6a5eaf1332f8278dc0f41643fd6783a7</Anchor>
    <Abstract>Is the class definition local to the module shared object?</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_final</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>type_record</Scope>
    </TokenIdentifier>
    <Path>structtype__record.html</Path>
    <Anchor>a9d4aeabde609f1324a518fc657ce7352</Anchor>
    <Abstract>Is the class inheritable from python classes?</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>UnboundStruct</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>UnboundStruct</Scope>
    </TokenIdentifier>
    <Path>struct_unbound_struct.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unchecked_mutable_reference</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>unchecked_mutable_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__mutable__reference.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator()</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_mutable_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__mutable__reference.html</Path>
    <Anchor>a1dc6e7e35c5957b7ab3dbcca9fa7e60a</Anchor>
    <Abstract>Mutable, unchecked access to data at the given indices.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator[]</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_mutable_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__mutable__reference.html</Path>
    <Anchor>a9580101363d95e99c1cf2d58d072c289</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mutable_data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_mutable_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__mutable__reference.html</Path>
    <Anchor>a7af40f1be08cf6c15f37a52c129ca9ff</Anchor>
    <Abstract>Mutable pointer access to the data at the given indices.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator()</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a0da3998ef32834892f5b59529db3efd5</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator[]</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a97fd086abe6908571f2089398d476105</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a993c4ac6e09e82442f1d9741765faa97</Anchor>
    <Abstract>Pointer access to the data at the given indices.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>shape</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a5065c039307f9797f8d4dc8f9e422d82</Anchor>
    <Abstract>Returns the shape (i.e. size) of dimension dim</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ndim</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a732200223a8d47f248fb9bab843dbe7a</Anchor>
    <Abstract>Returns the number of dimensions of the array.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>size</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>af1713056b2abec0c2b0fa62e78464537</Anchor>
    <Abstract>Returns the total number of elements in the referenced array, i.e. the product of the shapes.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nbytes</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a9c15e1b4f748ca5d8396e637c4d9abb4</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>itemsize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a0f060b74bb4c9b5d2f3f87c0671f2766</Anchor>
    <Abstract>Returns the item size, i.e. sizeof(T)</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unchecked_reference</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator()</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a0da3998ef32834892f5b59529db3efd5</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator[]</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a97fd086abe6908571f2089398d476105</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a993c4ac6e09e82442f1d9741765faa97</Anchor>
    <Abstract>Pointer access to the data at the given indices.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>shape</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a5065c039307f9797f8d4dc8f9e422d82</Anchor>
    <Abstract>Returns the shape (i.e. size) of dimension dim</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ndim</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a732200223a8d47f248fb9bab843dbe7a</Anchor>
    <Abstract>Returns the number of dimensions of the array.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>size</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>af1713056b2abec0c2b0fa62e78464537</Anchor>
    <Abstract>Returns the total number of elements in the referenced array, i.e. the product of the shapes.</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nbytes</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a9c15e1b4f748ca5d8396e637c4d9abb4</Anchor>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>itemsize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>unchecked_reference</Scope>
    </TokenIdentifier>
    <Path>classunchecked__reference.html</Path>
    <Anchor>a0f060b74bb4c9b5d2f3f87c0671f2766</Anchor>
    <Abstract>Returns the item size, i.e. sizeof(T)</Abstract>
    <DeclaredIn>numpy.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>undefined_t</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>undefined_t</Scope>
    </TokenIdentifier>
    <Path>structundefined__t.html</Path>
    <Abstract>Type for an unused type slot.</Abstract>
    <DeclaredIn>operators.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unique_ptr_with_addressof_operator</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>unique_ptr_with_addressof_operator</Scope>
    </TokenIdentifier>
    <Path>classunique__ptr__with__addressof__operator.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unpacking_collector</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>unpacking_collector</Scope>
    </TokenIdentifier>
    <Path>classunpacking__collector.html</Path>
    <Abstract>Helper class which collects positional, keyword, * and ** arguments for a Python function call.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>call</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>unpacking_collector</Scope>
    </TokenIdentifier>
    <Path>classunpacking__collector.html</Path>
    <Anchor>a3df5e4ecbc1a9fd31788c59053444de3</Anchor>
    <Abstract>Call a Python function and pass the collected arguments.</Abstract>
    <DeclaredIn>cast.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>UnregisteredBase</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>UnregisteredBase</Scope>
    </TokenIdentifier>
    <Path>class_unregistered_base.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>UnregisteredType</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>UnregisteredType</Scope>
    </TokenIdentifier>
    <Path>struct_unregistered_type.html</Path>
    <Abstract>Dummy type which is not exported anywhere â€“ something to trigger a conversion error.</Abstract>
    <DeclaredIn>pybind11_tests.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>UserType</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>UserType</Scope>
    </TokenIdentifier>
    <Path>class_user_type.html</Path>
    <Abstract>A user-defined type which is exported and can be used by any test.</Abstract>
    <DeclaredIn>pybind11_tests.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>type_caster&lt; Eigen::Ref&lt; PlainObjectType, 0, StrideType &gt;, enable_if_t&lt; is_eigen_dense_map&lt; Eigen::Ref&lt; PlainObjectType, 0, StrideType &gt; &gt;::value &gt;&gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>value &gt;&gt;</Scope>
    </TokenIdentifier>
    <Path>structtype__caster_3_01_eigen_1_1_ref_3_01_plain_object_type_00_010_00_01_stride_type_01_4_00_014483c445e66b0d8d9bb7fc2aa837ecac.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>value_and_holder</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>value_and_holder</Scope>
    </TokenIdentifier>
    <Path>structvalue__and__holder.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>values_and_holders</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>values_and_holders</Scope>
    </TokenIdentifier>
    <Path>structvalues__and__holders.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>values_and_holders::iterator</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>values_and_holders::iterator</Scope>
    </TokenIdentifier>
    <Path>structvalues__and__holders_1_1iterator.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Vanilla</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Vanilla</Scope>
    </TokenIdentifier>
    <Path>struct_vanilla.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>VanillaStaticMix1</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>VanillaStaticMix1</Scope>
    </TokenIdentifier>
    <Path>struct_vanilla_static_mix1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>VanillaStaticMix2</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>VanillaStaticMix2</Scope>
    </TokenIdentifier>
    <Path>struct_vanilla_static_mix2.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>variant_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>variant_caster</Scope>
    </TokenIdentifier>
    <Path>structvariant__caster.html</Path>
    <Abstract>Generic variant caster.</Abstract>
    <DeclaredIn>stl.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>variant_caster&lt; V&lt; Ts... &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>variant_caster&lt; V&lt; Ts... &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structvariant__caster_3_01_v_3_01_ts_8_8_8_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>variant_caster_visitor</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>variant_caster_visitor</Scope>
    </TokenIdentifier>
    <Path>structvariant__caster__visitor.html</Path>
    <Abstract>Visit a variant and cast any found type to Python.</Abstract>
    <DeclaredIn>stl.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Vector2</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Vector2</Scope>
    </TokenIdentifier>
    <Path>class_vector2.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>vector_has_data_and_format</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>vector_has_data_and_format</Scope>
    </TokenIdentifier>
    <Path>structvector__has__data__and__format.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>vector_has_data_and_format&lt; Vector, enable_if_t&lt; std::is_same&lt; decltype(format_descriptor&lt; typename Vector::value_type &gt;::format(), std::declval&lt; Vector &gt;().data()), typename Vector::value_type * &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>vector_has_data_and_format&lt; Vector, enable_if_t&lt; std::is_same&lt; decltype(format_descriptor&lt; typename Vector::value_type &gt;::format(), std::declval&lt; Vector &gt;().data()), typename Vector::value_type * &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structvector__has__data__and__format_3_01_vector_00_01enable__if__t_3_01std_1_1is__same_3_01decl747d65b4a7fb391eecda178e3ef74ddd.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>vectorize_arg</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>vectorize_arg</Scope>
    </TokenIdentifier>
    <Path>structvectorize__arg.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>vectorize_helper</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>vectorize_helper</Scope>
    </TokenIdentifier>
    <Path>structvectorize__helper.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>VirtClass</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>VirtClass</Scope>
    </TokenIdentifier>
    <Path>class_virt_class.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>visit_helper</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>visit_helper</Scope>
    </TokenIdentifier>
    <Path>structvisit__helper.html</Path>
    <DeclaredIn>stl.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>void_caster</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>void_caster</Scope>
    </TokenIdentifier>
    <Path>structvoid__caster.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>void_t_impl</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>void_t_impl</Scope>
    </TokenIdentifier>
    <Path>structvoid__t__impl.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>void_type</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>void_type</Scope>
    </TokenIdentifier>
    <Path>structvoid__type.html</Path>
    <Abstract>Helper type to replace &apos;void&apos; in some expressions.</Abstract>
    <DeclaredIn>common.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>weakref</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>weakref</Scope>
    </TokenIdentifier>
    <Path>classweakref.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Widget</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>Widget</Scope>
    </TokenIdentifier>
    <Path>class_widget.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>WithStatic1</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>WithStatic1</Scope>
    </TokenIdentifier>
    <Path>struct_with_static1.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>WithStatic2</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>WithStatic2</Scope>
    </TokenIdentifier>
    <Path>struct_with_static2.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>atm</Name>
      <APILanguage>c</APILanguage>
      <Type>ns</Type>
      <Scope>atm</Scope>
    </TokenIdentifier>
    <Path>namespaceatm.html</Path>
    <Abstract>The atm namespace contain all the classes, methods and other application that are provided by libAATM...</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal</Name>
      <APILanguage>c</APILanguage>
      <Type>ns</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Abstract>The API to create, simulate and observe an atmosphere are contained in the cal namespace.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>atm_get_absorption_coefficient</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>ae9f386cad2144ef71aa77bb3c80a10d5</Anchor>
    <DeclaredIn>AATM_fun.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>atm_get_absorption_coefficient_vec</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a6a6c55ef2c2f708f3c8d6e2beb2b4af0</Anchor>
    <DeclaredIn>AATM_fun.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>atm_get_atmospheric_loading</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a2d60e5a5310514f346dade9ceb1f30c6</Anchor>
    <DeclaredIn>AATM_fun.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>atm_get_atmospheric_loading_vec</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>af64d2ecbad505719a72bc20952e56664</Anchor>
    <DeclaredIn>AATM_fun.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rng_dist_uint64</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a119420eb035fa21d5757ec9e3aa17794</Anchor>
    <DeclaredIn>math_rng.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rng_dist_uniform_01</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>ad85ba135719e986379571382ea3dc993</Anchor>
    <DeclaredIn>math_rng.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rng_dist_uniform_11</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>af22d8436182a61d901904c393083816f</Anchor>
    <DeclaredIn>math_rng.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rng_dist_normal</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>af67347a20a21ec50aaf3107e8904faa0</Anchor>
    <DeclaredIn>math_rng.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rng_multi_dist_uint64</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>aee26a2086905116e32d0f8c667c6034a</Anchor>
    <DeclaredIn>math_rng.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rng_multi_dist_uniform_01</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a0cac030c480b3f2dfa9f4c793a448d20</Anchor>
    <DeclaredIn>math_rng.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rng_multi_dist_uniform_11</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a9df229f80e9c3ae03920b572be0e28d6</Anchor>
    <DeclaredIn>math_rng.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rng_multi_dist_normal</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>ac540295cd153689d6a8ce2e5d8be6b4c</Anchor>
    <DeclaredIn>math_rng.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>vsin</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a7b8aad7781991be09263a3540ff605b5</Anchor>
    <DeclaredIn>math_sf.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>aligned_alloc</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>ab3145476ef45c8b3175f43deabdcbaa5</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>aligned_free</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a386b2fd552bee380dded079e25942fd3</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>is_aligned</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>acff47c45d5620ce01acfc4b02a6a55d5</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>ac006cd5b1735a42dce13253f638fe5db</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mpi_init</Name>
      <APILanguage>cpp</APILanguage>
      <Type>func</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a7bcb0ec3f9aac1061e3281f30e720501</Anchor>
    <DeclaredIn>mpi_init.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>SIMD_ALIGN</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a783a71b5d055b3cdf4c6f66fab0d69fe</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>SIMD_ALIGN</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a783a71b5d055b3cdf4c6f66fab0d69fe</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a334c4a4c42fdb79d7ebc3e73b517e6f8</Anchor>
    <Abstract>Undefined.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>debug</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650aad42f6697b035b7580e4fef93be20b4d</Anchor>
    <Abstract>Debug.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>info</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650acaf9b6b99962bf5c2264824231d7a40c</Anchor>
    <Abstract>Info.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>warning</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a7b83d3f08fa392b79e3f553b585971cd</Anchor>
    <Abstract>Warning.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650acb5e100e5a9a3e7f6d1fd97512215282</Anchor>
    <Abstract>Error.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>critical</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a7e85bcb66fb9a809d5ab4f62a8b8bea8</Anchor>
    <Abstract>Critical.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a334c4a4c42fdb79d7ebc3e73b517e6f8</Anchor>
    <Abstract>Undefined.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>debug</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650aad42f6697b035b7580e4fef93be20b4d</Anchor>
    <Abstract>Debug.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>info</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650acaf9b6b99962bf5c2264824231d7a40c</Anchor>
    <Abstract>Info.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>warning</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a7b83d3f08fa392b79e3f553b585971cd</Anchor>
    <Abstract>Warning.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650acb5e100e5a9a3e7f6d1fd97512215282</Anchor>
    <Abstract>Error.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>critical</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a7e85bcb66fb9a809d5ab4f62a8b8bea8</Anchor>
    <Abstract>Critical.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a334c4a4c42fdb79d7ebc3e73b517e6f8</Anchor>
    <Abstract>Undefined.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>debug</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650aad42f6697b035b7580e4fef93be20b4d</Anchor>
    <Abstract>Debug.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>info</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650acaf9b6b99962bf5c2264824231d7a40c</Anchor>
    <Abstract>Info.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>warning</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a7b83d3f08fa392b79e3f553b585971cd</Anchor>
    <Abstract>Warning.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650acb5e100e5a9a3e7f6d1fd97512215282</Anchor>
    <Abstract>Error.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>critical</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a7e85bcb66fb9a809d5ab4f62a8b8bea8</Anchor>
    <Abstract>Critical.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>none</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a334c4a4c42fdb79d7ebc3e73b517e6f8</Anchor>
    <Abstract>Undefined.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>debug</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650aad42f6697b035b7580e4fef93be20b4d</Anchor>
    <Abstract>Debug.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>info</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650acaf9b6b99962bf5c2264824231d7a40c</Anchor>
    <Abstract>Info.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>warning</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a7b83d3f08fa392b79e3f553b585971cd</Anchor>
    <Abstract>Warning.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>error</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650acb5e100e5a9a3e7f6d1fd97512215282</Anchor>
    <Abstract>Error.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>critical</Name>
      <APILanguage>cpp</APILanguage>
      <Type>econst</Type>
      <Scope>cal</Scope>
    </TokenIdentifier>
    <Path>namespacecal.html</Path>
    <Anchor>a3138bdc499850a0f54c75de0ffa0a650a7e85bcb66fb9a809d5ab4f62a8b8bea8</Anchor>
    <Abstract>Critical.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::AlignedAllocator</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Abstract>Allocator that can be used with STL containers.</Abstract>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>value_type</Name>
      <APILanguage>cpp</APILanguage>
      <Type>tdef</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a645f829de2dadb54edd5eadd25a50c5a</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>value_type</Name>
      <APILanguage>cpp</APILanguage>
      <Type>tdef</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a645f829de2dadb54edd5eadd25a50c5a</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>address</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a76250bc0dddc2f0ba6b2e22cc13b1e19</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>max_size</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a7ef710c71179c67d705bf9c88cab075e</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>allocate</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>ae432e8d27768e7843364e3c941aa8f07</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>construct</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>ac255471f9f681c53b6d9180e28f38a97</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>destroy</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a5be86277ae3299ae8aa1872e569d9552</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>deallocate</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a2324f0236470b9519ea7291b22c8fa74</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>address</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a76250bc0dddc2f0ba6b2e22cc13b1e19</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>max_size</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a7ef710c71179c67d705bf9c88cab075e</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>allocate</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>ae432e8d27768e7843364e3c941aa8f07</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>construct</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>ac255471f9f681c53b6d9180e28f38a97</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>destroy</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a5be86277ae3299ae8aa1872e569d9552</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>deallocate</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::AlignedAllocator</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_aligned_allocator.html</Path>
    <Anchor>a2324f0236470b9519ea7291b22c8fa74</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::AlignedAllocator::rebind</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>cal::AlignedAllocator::rebind</Scope>
    </TokenIdentifier>
    <Path>structcal_1_1_aligned_allocator_1_1rebind.html</Path>
    <Abstract>allocator to type U</Abstract>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::atm_sim</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Abstract>Atmosphere creation, evolution and observation.</Abstract>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pshr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>tdef</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a2efa147f5c40596b8691aca2ac117b4e</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>puniq</Name>
      <APILanguage>cpp</APILanguage>
      <Type>tdef</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>ab71557f3645d93a8f938d1de4b3ca537</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>atm_sim</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a4c84a0904937df49a959f138a51e8070</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~atm_sim</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a064b7336503ca3f5765e498d6932bf65</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>simulate</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>aa1b57cf734827f16c185e5b360a61304</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>observe</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a09f101d0f619a8b332ded6086a239011</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>print</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a87e928417af7835946935bd1e5924725</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>draw</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a1e80fd5484d31babaa988cb9548217c5</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get_volume</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a78fbf25d493cc3829dc1549115eccdda</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>in_cone</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>adb680fc272c1839241c9bedc99260381</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compress_volume</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a5d0e5635f88133858fa32fd1399481e7</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get_slice</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>ab1aa562093fbecc04cbbe34430901f00</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sqrt_sparse_covariance</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a88ba15ba34f30664f50feb493abc08b7</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>apply_sparse_covariance</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>afda9fbabb9aec95cae005f6f8c91cd9b</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ind2coord</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>abe59c32b1033744445f1f0fc7560ddfe</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>coord2ind</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a926aeaeed11baaf629bbeacdd1182fa8</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>interp</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a4de2152abacbe09d0e1918a3a602b3cc</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cov_eval</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a1d355122632b5761cda5e782e6bd9b56</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>initialize_kolmogorov</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a0c86db633c439e294ae7487c13a31ab9</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>kolmogorov</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>ab0e9c8b8c73323a1d134c9643c381891</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>smooth</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a67f89876f41b03d42659ba0a320ed351</Anchor>
    <DeclaredIn>CALAtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>tanmin</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a00553913e9d0f5a9a0a5c1348ba1e0fc</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a5f54691e621793733e29c7d34bb7fe2e</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nelem_sim_max</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a9c4aa288a0e7fb1f4159a69243b5c37c</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rmin_kolmo</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>ac86dbe5bd63fb8ee60c388f61a92d22c</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rcorr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>af86ced8dda72a44f84ad0d77fd0587a5</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rmin</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>a5a61a854d54dba6f705dbd043ad3d1d2</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compressed_index</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>ab961936c27c9b58799e845234dea0486</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>full_index</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1atm__sim.html</Path>
    <Anchor>afb3b80ebd3c9e5ac7f48d94809bdb836</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::Environment</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>cal::Environment</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_environment.html</Path>
    <Abstract>Singleton in order to get the environment set-up. get the current_thread, the maximum number of threa...</Abstract>
    <DeclaredIn>sys_env.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::GlobalTimers</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>cal::GlobalTimers</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_global_timers.html</Path>
    <Abstract>Singleton registry of global timers that can be accessed from anywhere.</Abstract>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>cal::GlobalTimers</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_global_timers.html</Path>
    <Anchor>afc9c81379a4cef12742ae5a91c9de613</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>cal::GlobalTimers</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_global_timers.html</Path>
    <Anchor>a29aa3303aadd67baac9f7f7dfac6608e</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>GlobalTimers</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::GlobalTimers</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_global_timers.html</Path>
    <Anchor>a5cbcdc55c6a1ba18186845bdb33164a2</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>GlobalTimers</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::GlobalTimers</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_global_timers.html</Path>
    <Anchor>a5cbcdc55c6a1ba18186845bdb33164a2</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>data</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::GlobalTimers</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_global_timers.html</Path>
    <Anchor>aed40e4295d4629ea44d40ff6a2417eef</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::Logger</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>cal::Logger</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_logger.html</Path>
    <Abstract>Global logger singleton.</Abstract>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>cal::Logger</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_logger.html</Path>
    <Anchor>a5dd5ea55fa2dea98ff7b3a4fa2732b1f</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get</Name>
      <APILanguage>cpp</APILanguage>
      <Type>clm</Type>
      <Scope>cal::Logger</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_logger.html</Path>
    <Anchor>ab8e6eba442c7fbfc73b25192e109cfb8</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Logger</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::Logger</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_logger.html</Path>
    <Anchor>ae1a855284bfcc2a8f7ec0b8c00b936d0</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>Logger</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::Logger</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_logger.html</Path>
    <Anchor>ae1a855284bfcc2a8f7ec0b8c00b936d0</Anchor>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::mpi_atm_sim</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Abstract>Atmosphere creation, evolution and observation with MPI support.</Abstract>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pshr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>tdef</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>abf42824b9beb670cc010ea44cc649640</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>puniq</Name>
      <APILanguage>cpp</APILanguage>
      <Type>tdef</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>add9711542d8f0a61908f606e50c8cedc</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mpi_atm_sim</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>acde90f60b6705631bac070390b314e0e</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~mpi_atm_sim</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>add5e6b1af0cefd6f3b91ff143d029548</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>simulate</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a52c1496f8a7aed634b509e873ff1aae8</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>observe</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a7fba376df3be33c52ba21aeabaf00e6d</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>print</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>ab3e9a8a4e02d7cf637f453c979c1b0e0</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>draw</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>ab3b68a9b3d9a1771b0a2819e19ee2292</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get_volume</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>af3f82895dc6b9d7428287097169e23e2</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>in_cone</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>add80419c1a7fc88b21fafb026dcc3d66</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compress_volume</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a0e6e97d40f52f7722dc9ecfd4c80b854</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>get_slice</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>ab0a7384394f30859b92d1a7449358245</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>sqrt_sparse_covariance</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a104df232c41e3b88e67d16d07c5e9a38</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>build_sparse_covariance</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a41a32382f158d3465ef1c61209782ac1</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>apply_sparse_covariance</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a9a45e22f3fe7856742c860e0c3a5cd88</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ind2coord</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a54b67379b62c3b1a86690c3f7d126bcb</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>coord2ind</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>addaac0ae73aac5a931ec4a0bcb925ed8</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>interp</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a58998faf6f9fcad0c3b389ba94304371</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cov_eval</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a10b842b6e86b9956b103d1d6d242769c</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>initialize_kolmogorov</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>aa5c52f70344da8885c0f83cc4ac39ff2</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>kolmogorov</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a4c3d9def372814fa429a8ad20e9f9e67</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>smooth</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a510f7befa1310831fb9553de4d273d18</Anchor>
    <DeclaredIn>CAL_MPI_AtmSim.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>tanmin</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a565dc0bc8a483889547967690f946ae7</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a2a125c7eb5f3035072b4c3b226e602f8</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nelem_sim_max</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a0eae386d18257e5ed689d742467d390d</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rmin_kolmo</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a1b103396821703f7ae68472ac275dcc6</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rcorr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>aaf0f5bce33029dd80e9863b271977894</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>rmin</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>ab741ee3a28ec4668e9ccd16757a96d01</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>compressed_index</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>a34a4da442e435263906b8ea03936f690</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>full_index</Name>
      <APILanguage>cpp</APILanguage>
      <Type>data</Type>
      <Scope>cal::mpi_atm_sim</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__atm__sim.html</Path>
    <Anchor>acd082378607d90f3ca6dd710f8634544</Anchor>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::mpi_shmem</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>cal::mpi_shmem</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__shmem.html</Path>
    <DeclaredIn>atm_shm.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>allocate</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_shmem</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__shmem.html</Path>
    <Anchor>a1f9f3de09ef5b87435c1ee88d9b1d78c</Anchor>
    <DeclaredIn>atm_shm.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>resize</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>cal::mpi_shmem</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1mpi__shmem.html</Path>
    <Anchor>a63e74a861a8b9aa7a77554096af5a8c8</Anchor>
    <DeclaredIn>atm_shm.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cal::Timer</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>cal::Timer</Scope>
    </TokenIdentifier>
    <Path>classcal_1_1_timer.html</Path>
    <Abstract>Simple timer class that tracks elapsed seconds and number of times it was started.</Abstract>
    <DeclaredIn>sys_utils.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>conftest</Name>
      <APILanguage>python</APILanguage>
      <Type>ns</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_strip_and_dedent</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>af62df87eb4607f44da303443edfe9a99</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_split_and_sort</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>a5e4d8610b6c0f0c7e53d5c26a959ece8</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_make_explanation</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>abc00aae985b1c675f581befa2e270e96</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>capture</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>aad7bbb453045d1770805438a473317a4</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>doc</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>a35de28597d48d0a25c748a140765032e</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>msg</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>a8232d5538ccdf81352ae8d484548864e</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pytest_assertrepr_compare</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>ae323d6c25dca1e94101a23a65a3b2ba5</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>suppress</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>a91c661a91528bcb9b6c5f6acbc7f6558</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>gc_collect</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>ae5bb8caa851371d0b8576827a6a20f0f</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pytest_configure</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>abf6aaa58b0abe123198ba68fb26350d5</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_test_import_pybind11</Name>
      <APILanguage>python</APILanguage>
      <Type>func</Type>
      <Scope>conftest</Scope>
    </TokenIdentifier>
    <Path>namespaceconftest.html</Path>
    <Anchor>ae518ca03c369fb5c25b213f17bd68e28</Anchor>
    <DeclaredIn>conftest.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>conftest::Capture</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>conftest.Capture</Scope>
    </TokenIdentifier>
    <Path>classconftest_1_1_capture.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>conftest::Output</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>conftest.Output</Scope>
    </TokenIdentifier>
    <Path>classconftest_1_1_output.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>conftest::SanitizedString</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>conftest.SanitizedString</Scope>
    </TokenIdentifier>
    <Path>classconftest_1_1_sanitized_string.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>conftest::Unordered</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>conftest.Unordered</Scope>
    </TokenIdentifier>
    <Path>classconftest_1_1_unordered.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mkdoc::ExtractionThread</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>mkdoc.ExtractionThread</Scope>
    </TokenIdentifier>
    <Path>classmkdoc_1_1_extraction_thread.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>mkdoc::NoFilenamesError</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>mkdoc.NoFilenamesError</Scope>
    </TokenIdentifier>
    <Path>classmkdoc_1_1_no_filenames_error.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pets::Pet</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>pets::Pet</Scope>
    </TokenIdentifier>
    <Path>classpets_1_1_pet.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pybind11::polymorphic_type_hook&lt; itype, detail::enable_if_t&lt; std::is_base_of&lt; Animal, itype &gt;::value &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>pybind11::polymorphic_type_hook&lt; itype, detail::enable_if_t&lt; std::is_base_of&lt; Animal, itype &gt;::value &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structpybind11_1_1polymorphic__type__hook_3_01itype_00_01detail_1_1enable__if__t_3_01std_1_1is__e83df67915b55f3d6bd9d21e755ef80f.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pybind11::detail::holder_helper&lt; ref&lt; T &gt; &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>pybind11::detail::holder_helper&lt; ref&lt; T &gt; &gt;</Scope>
    </TokenIdentifier>
    <Path>structpybind11_1_1detail_1_1holder__helper_3_01ref_3_01_t_01_4_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pybind11::detail::type_caster&lt; ArgAlwaysConverts &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>pybind11::detail::type_caster&lt; ArgAlwaysConverts &gt;</Scope>
    </TokenIdentifier>
    <Path>structpybind11_1_1detail_1_1type__caster_3_01_arg_always_converts_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pybind11::detail::type_caster&lt; ArgInspector1 &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>pybind11::detail::type_caster&lt; ArgInspector1 &gt;</Scope>
    </TokenIdentifier>
    <Path>structpybind11_1_1detail_1_1type__caster_3_01_arg_inspector1_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pybind11::detail::type_caster&lt; ArgInspector2 &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>pybind11::detail::type_caster&lt; ArgInspector2 &gt;</Scope>
    </TokenIdentifier>
    <Path>structpybind11_1_1detail_1_1type__caster_3_01_arg_inspector2_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pybind11::detail::type_caster&lt; DestructionTester &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>pybind11::detail::type_caster&lt; DestructionTester &gt;</Scope>
    </TokenIdentifier>
    <Path>structpybind11_1_1detail_1_1type__caster_3_01_destruction_tester_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::cache::Cache</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>clear</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>a103f2b2f042c41f44fea7eab4e9c9cf0</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>create</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>ad63f85b0fd7a19cfca1944f7ef1d2292</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>put</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>a4c7bdee7385a29e52b034f96bb751fcd</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>add_alias</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>ae3b6273e52035f64154112f10aaf25bf</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>destroy</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>a3fd96ba982f1eca4cc117cdfa8f7908d</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>exists</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>a9d34e07145794bfc3d23dc9021a0e364</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>reference</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>a0a8a9a795e258ffacb9b7570b7ca3b02</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>keys</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>a487bb62878b52a8b0c465e31ba72bd83</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>aliases</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>a7c0f905cc54e8e16631bc7f13fa0e73b</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>report</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.cache.Cache</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1cache_1_1_cache.html</Path>
    <Anchor>acda569b1528d4636658be7163691ef6b</Anchor>
    <DeclaredIn>cache.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::dist::Data</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.dist.Data</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1dist_1_1_data.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>comm</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.dist.Data</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1dist_1_1_data.html</Path>
    <Anchor>a7d45194f2a7b693f081da6d3b2ec2712</Anchor>
    <DeclaredIn>dist.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>clear</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.dist.Data</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1dist_1_1_data.html</Path>
    <Anchor>ae517a23004d3f79753f8ebad727c1843</Anchor>
    <DeclaredIn>dist.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>info</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.dist.Data</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1dist_1_1_data.html</Path>
    <Anchor>a0f27f6fdb10036c2c900e05446852e41</Anchor>
    <DeclaredIn>dist.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>split</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.dist.Data</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1dist_1_1_data.html</Path>
    <Anchor>a15544fb4ddc14de4b136bcb4b66279c6</Anchor>
    <DeclaredIn>dist.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::mpi::Comm</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>world_size</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>a8453456792a581a039b51f695f2866a4</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>world_rank</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>aef1ab9de83eaa00cd432b2795ced31d9</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ngroups</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>a5259604c988d294cc4fc5493ce631271</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>group</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>a636fd91b72ccb85e76d7e1c9640635b1</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>group_size</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>ac323805bf823c9d8183e0c031f578dac</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>group_rank</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>ae0845f4d4f0cc2ddc47282a28ec134f5</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>comm_world</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>a319b0fa08b1e2be3f6bbdd5ea883fa5d</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>comm_group</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>a3162234cd2deeabcfe4a604b98394315</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>comm_rank</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.Comm</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_comm.html</Path>
    <Anchor>a1d453c42c402b6cbcb0f808d3e3a6d2a</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::mpi::MPILock</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.mpi.MPILock</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_lock.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>comm</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.MPILock</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_lock.html</Path>
    <Anchor>a17b755492462936b044a7c8f688f4d9f</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>lock</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.MPILock</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_lock.html</Path>
    <Anchor>a108ddc5c77094d3dfbec8f228a440280</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>unlock</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.MPILock</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_lock.html</Path>
    <Anchor>af84f3c605f0812d5b46da80addfd6dc4</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::mpi::MPIShared</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.mpi.MPIShared</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_shared.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>shape</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.MPIShared</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_shared.html</Path>
    <Anchor>a202fd28eca15f3abbfe9e9d44a674224</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dtype</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.MPIShared</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_shared.html</Path>
    <Anchor>a09a9a294e703139c6995237e6ce0ab3c</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>comm</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.MPIShared</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_shared.html</Path>
    <Anchor>a074d9d6d9970ba302e9bc795095a6c11</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>nodecomm</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.MPIShared</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_shared.html</Path>
    <Anchor>a4389949dab062f5190ab15a84e643c3b</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>set</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.mpi.MPIShared</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1mpi_1_1_m_p_i_shared.html</Path>
    <Anchor>a01a4b63c3fb8c32721e45d2ce7c31ea7</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::op::Operator</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.op.Operator</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1op_1_1_operator.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>exec</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.op.Operator</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1op_1_1_operator.html</Path>
    <Anchor>af40922bdae44d1b640f4271c03926302</Anchor>
    <DeclaredIn>op.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::binned::BinnedTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.binned.BinnedTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1binned_1_1_binned_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::cache::CacheTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.cache.CacheTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1cache_1_1_cache_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::cov::CovarianceTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.cov.CovarianceTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1cov_1_1_covariance_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::dist::DataTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.dist.DataTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1dist_1_1_data_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::env::EnvTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.env.EnvTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1env_1_1_env_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::fft::FFTTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.fft.FFTTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1fft_1_1_f_f_t_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::healpix::HealpixTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.healpix.HealpixTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1healpix_1_1_healpix_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::intervals::IntervalTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.intervals.IntervalTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1intervals_1_1_interval_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::map_ground::MapGroundTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.map_ground.MapGroundTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1map__ground_1_1_map_ground_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::map_satellite::MapSatelliteTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.map_satellite.MapSatelliteTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1map__satellite_1_1_map_satellite_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::mpi::_WritelnDecorator</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.mpi._WritelnDecorator</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1mpi_1_1___writeln_decorator.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::mpi::MPITestCase</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.mpi.MPITestCase</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1mpi_1_1_m_p_i_test_case.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::mpi::MPITestResult</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.mpi.MPITestResult</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1mpi_1_1_m_p_i_test_result.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::mpi::MPITestRunner</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.mpi.MPITestRunner</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1mpi_1_1_m_p_i_test_runner.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.tests.mpi.MPITestRunner</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1mpi_1_1_m_p_i_test_runner.html</Path>
    <Anchor>aaa5ae490e988aa9462dd234d56266e5e</Anchor>
    <DeclaredIn>mpi.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_applygain::TestApplyGain</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_applygain.TestApplyGain</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__applygain_1_1_test_apply_gain.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_dipole::OpSimDipoleTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_dipole.OpSimDipoleTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__dipole_1_1_op_sim_dipole_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_gainscrambler::OpGainScramblerTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_gainscrambler.OpGainScramblerTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__gainscrambler_1_1_op_gain_scrambler_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_groundfilter::OpGroundFilterTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_groundfilter.OpGroundFilterTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__groundfilter_1_1_op_ground_filter_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_madam::OpMadamTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_madam.OpMadamTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__madam_1_1_op_madam_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_mapmaker::OpMapMakerTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_mapmaker.OpMapMakerTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__mapmaker_1_1_op_map_maker_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_memorycounter::OpMemoryCounterTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_memorycounter.OpMemoryCounterTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__memorycounter_1_1_op_memory_counter_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_pmat::OpPointingHpixTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_pmat.OpPointingHpixTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__pmat_1_1_op_pointing_hpix_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_polyfilter::OpPolyFilterTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_polyfilter.OpPolyFilterTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__polyfilter_1_1_op_poly_filter_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_sim_atm::OpsSimAtmosphereTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_sim_atm.OpsSimAtmosphereTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__sim__atm_1_1_ops_sim_atmosphere_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_sim_pysm::OpSimPySMTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_sim_pysm.OpSimPySMTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__sim__pysm_1_1_op_sim_py_s_m_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_sim_pysm::OpSimPySMTestSmooth</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_sim_pysm.OpSimPySMTestSmooth</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__sim__pysm_1_1_op_sim_py_s_m_test_smooth.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_sim_sss::OpSimScanSynchronousSignalTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_sim_sss.OpSimScanSynchronousSignalTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__sim__sss_1_1_op_sim_scan_synchronous_signal_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::ops_simnoise::OpSimNoiseTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.ops_simnoise.OpSimNoiseTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1ops__simnoise_1_1_op_sim_noise_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::psd_math::PSDTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.psd_math.PSDTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1psd__math_1_1_p_s_d_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::qarray::QarrayTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.qarray.QarrayTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1qarray_1_1_qarray_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::rng::RNGTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.rng.RNGTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1rng_1_1_r_n_g_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::sim_focalplane::SimFocalplaneTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.sim_focalplane.SimFocalplaneTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1sim__focalplane_1_1_sim_focalplane_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::tidas::TidasTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.tidas.TidasTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1tidas_1_1_tidas_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::timing::TimingTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.timing.TimingTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1timing_1_1_timing_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::tod::TODTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.tod.TODTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1tod_1_1_t_o_d_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::tests::tod_satellite::TODSatelliteTest</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.tests.tod_satellite.TODSatelliteTest</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1tests_1_1tod__satellite_1_1_t_o_d_satellite_test.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::todmap::sim_det_atm::OpSimAtmosphere</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.todmap.sim_det_atm.OpSimAtmosphere</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1todmap_1_1sim__det__atm_1_1_op_sim_atmosphere.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>exec</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.todmap.sim_det_atm.OpSimAtmosphere</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1todmap_1_1sim__det__atm_1_1_op_sim_atmosphere.html</Path>
    <Anchor>ab9550ae5cb9f0781ad6725ea2edae9e1</Anchor>
    <DeclaredIn>sim_det_atm.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_plot_snapshots</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.todmap.sim_det_atm.OpSimAtmosphere</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1todmap_1_1sim__det__atm_1_1_op_sim_atmosphere.html</Path>
    <Anchor>ab5b63b6c0214451081035031d5bcb5ef</Anchor>
    <DeclaredIn>sim_det_atm.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_get_from_obs</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.todmap.sim_det_atm.OpSimAtmosphere</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1todmap_1_1sim__det__atm_1_1_op_sim_atmosphere.html</Path>
    <Anchor>a4274842ca74bd599eaa5027d06f6152a</Anchor>
    <DeclaredIn>sim_det_atm.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_get_rng_keys</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.todmap.sim_det_atm.OpSimAtmosphere</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1todmap_1_1sim__det__atm_1_1_op_sim_atmosphere.html</Path>
    <Anchor>aeb0ef04c1ae4a87d10d906ea572a4f9a</Anchor>
    <DeclaredIn>sim_det_atm.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pycal::weather::Weather</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>__init__</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a7895bce849df2a795875c9b057e00a49</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>set</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a084a5df60b2fefa88a6c18054ec1c608</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>set_time</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a73c2646f0cd70d3e86b53230f6ce2a98</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ice_water</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a8c5b5235f20a4ca3fcc9410afc593d7c</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>liquid_water</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a4f7cd1e5cc63a4cfd656544bc483e3b8</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>pwv</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>abf24a8753fd235088ef982b267c3694c</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>humidity</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>aa5565bc93c191b5887648a4fce1c441f</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>surface_pressure</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a33e017ee83182fba4edb1a0951ffbb1d</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>surface_temperature</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a2d01fd5b72748a31949192251738f598</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>air_temperature</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a0ddd034fc52aec7bfe65ca605211a872</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>west_wind</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a3755f1d43ede2c2346a459d7f037d55b</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>south_wind</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>ad4789f779a2d74d6c7d38c19e7fd45f1</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a6537d8aee1fc94555af84e5bb9ecad21</Anchor>
    <Abstract>Copy constructor; always increases the reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a3fc437bccb86b745433164bc3a04a2a4</Anchor>
    <Abstract>Move constructor; steals the object from other and preserves its reference count.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>~object</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>aecd824abdc96ff340acf4ea25a34d76d</Anchor>
    <Abstract>Destructor; automatically calls handle::dec_ref()</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>release</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>object</Scope>
    </TokenIdentifier>
    <Path>classobject.html</Path>
    <Anchor>a4ce66b1d44b37ae6b28e80228b075aae</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a53ba30cccfb1cabee421fd4ea555cf44</Anchor>
    <Abstract>The default constructor creates a handle with a nullptr-valued pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>handle</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a99eb912e1b9b823bc447980a16772584</Anchor>
    <Abstract>Creates a handle from the given raw Python object pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>ptr</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>afcd412ba4cbffd7d1e3c9338746b2682</Anchor>
    <Abstract>Return the underlying PyObject * pointer.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>inc_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>ab9c5f2cbecb0b37f53765b1c501b7451</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>dec_ref</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a03747f7b62a7b61eb7d9d1df25bfa7c4</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>cast</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a8158ff37b59a73d48140ab4d718316b9</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator bool</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a2c60694c460b2227f2a00c7b873d7436</Anchor>
    <Abstract>Return true when the handle wraps a valid Python object.</Abstract>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>operator==</Name>
      <APILanguage>cpp</APILanguage>
      <Type>instm</Type>
      <Scope>handle</Scope>
    </TokenIdentifier>
    <Path>classhandle.html</Path>
    <Anchor>a7173e778869746c1c7a071e561c79974</Anchor>
    <DeclaredIn>pytypes.h</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_reset_vars</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a6ba79778e3cb9197d681a99bb6688518</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>_draw</Name>
      <APILanguage>python</APILanguage>
      <Type>instm</Type>
      <Scope>pycal.weather.Weather</Scope>
    </TokenIdentifier>
    <Path>classpycal_1_1weather_1_1_weather.html</Path>
    <Anchor>a5a2d79862104478ec114c79a5de00d7f</Anchor>
    <DeclaredIn>weather.py</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>r123</Name>
      <APILanguage>c</APILanguage>
      <Type>ns</Type>
      <Scope>r123</Scope>
    </TokenIdentifier>
    <Path>namespacer123.html</Path>
    <Abstract>Most of the Random123 C++ API is contained in the r123 namespace.</Abstract>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>r123::Engine</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>r123::Engine</Scope>
    </TokenIdentifier>
    <Path>structr123_1_1_engine.html</Path>
    <DeclaredIn>Engine.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>r123::make_signed</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>r123::make_signed</Scope>
    </TokenIdentifier>
    <Path>structr123_1_1make__signed.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>r123::make_unsigned</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>r123::make_unsigned</Scope>
    </TokenIdentifier>
    <Path>structr123_1_1make__unsigned.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>r123::MicroURNG</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>r123::MicroURNG</Scope>
    </TokenIdentifier>
    <Path>classr123_1_1_micro_u_r_n_g.html</Path>
    <DeclaredIn>MicroURNG.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>r123::ReinterpretCtr</Name>
      <APILanguage>c</APILanguage>
      <Type>tmplt</Type>
      <Scope>r123::ReinterpretCtr</Scope>
    </TokenIdentifier>
    <Path>structr123_1_1_reinterpret_ctr.html</Path>
    <DeclaredIn>ReinterpretCtr.hpp</DeclaredIn>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setup::BuildPy</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>setup.BuildPy</Scope>
    </TokenIdentifier>
    <Path>classsetup_1_1_build_py.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>setup::InstallHeaders</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>setup.InstallHeaders</Scope>
    </TokenIdentifier>
    <Path>classsetup_1_1_install_headers.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>std::hash&lt; TplCtorClass &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>std::hash&lt; TplCtorClass &gt;</Scope>
    </TokenIdentifier>
    <Path>structstd_1_1hash_3_01_tpl_ctor_class_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>std::hash&lt; Vector2 &gt;</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>std::hash&lt; Vector2 &gt;</Scope>
    </TokenIdentifier>
    <Path>structstd_1_1hash_3_01_vector2_01_4.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>test_exc_sp::C</Name>
      <APILanguage>c</APILanguage>
      <Type>cl</Type>
      <Scope>test_exc_sp::C</Scope>
    </TokenIdentifier>
    <Path>structtest__exc__sp_1_1_c.html</Path>
  </Token>
  <Token>
    <TokenIdentifier>
      <Name>test_interpreter::DerivedWidget</Name>
      <APILanguage>python</APILanguage>
      <Type>cl</Type>
      <Scope>test_interpreter.DerivedWidget</Scope>
    </TokenIdentifier>
    <Path>classtest__interpreter_1_1_derived_widget.html</Path>
  </Token>
</Tokens>
